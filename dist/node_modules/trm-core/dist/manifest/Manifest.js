"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Manifest = void 0;
const xml = __importStar(require("xml-js"));
const semver = __importStar(require("semver"));
const commons_1 = require("../commons");
const trmPackage_1 = require("../trmPackage");
const registry_1 = require("../registry");
const normalize_url_1 = __importDefault(require("@esm2cjs/normalize-url"));
const email_validator_1 = require("email-validator");
const SpdxLicenseIds = __importStar(require("spdx-license-ids/index.json"));
const xmldom_1 = require("xmldom");
const xml_beautify_1 = __importDefault(require("xml-beautify"));
function getManifestAuthor(sAuthor) {
    var author = {};
    const emailRegex = new RegExp("<([^>]*)>");
    const email = emailRegex.exec(sAuthor);
    if (email) {
        author.email = email[1].toLowerCase();
        sAuthor = sAuthor.replace(`<${email[1]}>`, '');
    }
    author.name = sAuthor.trim();
    return author;
}
class Manifest {
    constructor(_manifest) {
        this._manifest = _manifest;
    }
    get(keepRuntimeValues = false) {
        return Manifest.normalize(this._manifest, keepRuntimeValues);
    }
    getKey(keepVersion = true) {
        const manifest = this.get();
        const registryEndpoint = this._manifest.registry;
        return `${manifest.name}${keepVersion ? manifest.version : ''}${registryEndpoint}`;
    }
    setDistFolder(dist) {
        this._manifest.distFolder = dist;
        return this;
    }
    setLinkedTransport(transport) {
        this._manifest.linkedTransport = transport;
        return this;
    }
    getLinkedTransport() {
        return this._manifest.linkedTransport;
    }
    setRegistryEndpoint(endpoint) {
        this._manifest.registry = endpoint;
    }
    getAbapXml() {
        const manifest = this.get();
        var oAbapXml = {
            "_declaration": {
                "_attributes": {
                    "version": "1.0",
                    "encoding": "utf-8"
                }
            },
            "asx:abap": {
                "_attributes": {
                    "xmlns:asx": "http://www.sap.com/abapxml",
                    "version": "1.0"
                },
                "asx:values": {
                    "TRM_MANIFEST": {
                        "NAME": {
                            "_text": manifest.name
                        },
                        "VERSION": {
                            "_text": manifest.version
                        }
                    }
                }
            }
        };
        if (manifest.description) {
            oAbapXml['asx:abap']['asx:values']['TRM_MANIFEST']['DESCRIPTION'] = {
                "_text": manifest.description
            };
        }
        if (manifest.private) {
            oAbapXml['asx:abap']['asx:values']['TRM_MANIFEST']['PRIVATE'] = {
                "_text": "X"
            };
        }
        if (manifest.backwardsCompatible) {
            oAbapXml['asx:abap']['asx:values']['TRM_MANIFEST']['BACKWARDS_COMPATIBLE'] = {
                "_text": "X"
            };
        }
        if (manifest.git) {
            oAbapXml['asx:abap']['asx:values']['TRM_MANIFEST']['GIT'] = {
                "_text": manifest.git
            };
        }
        if (manifest.website) {
            oAbapXml['asx:abap']['asx:values']['TRM_MANIFEST']['WEBSITE'] = {
                "_text": manifest.website
            };
        }
        if (manifest.license) {
            oAbapXml['asx:abap']['asx:values']['TRM_MANIFEST']['LICENSE'] = {
                "_text": manifest.license
            };
        }
        if (manifest.authors) {
            var authors = [];
            manifest.authors.forEach(o => {
                var obj = {};
                if (o.name) {
                    obj['NAME'] = {
                        "_text": o.name
                    };
                }
                if (o.email) {
                    obj['EMAIL'] = {
                        "_text": o.email
                    };
                }
                if (Object.keys(obj).length > 0) {
                    authors.push(obj);
                }
            });
            if (authors.length > 0) {
                oAbapXml['asx:abap']['asx:values']['TRM_MANIFEST']['AUTHORS'] = {
                    "item": authors
                };
            }
        }
        if (manifest.keywords) {
            var keywords = manifest.keywords.map(o => {
                return {
                    "_text": o
                };
            });
            if (keywords.length > 0) {
                oAbapXml['asx:abap']['asx:values']['TRM_MANIFEST']['KEYWORDS'] = {
                    "item": keywords
                };
            }
        }
        if (manifest.dependencies) {
            var dependencies = [];
            manifest.dependencies.forEach((o) => {
                var obj = {};
                if (o.name) {
                    obj['NAME'] = {
                        "_text": o.name
                    };
                }
                if (o.version) {
                    obj['VERSION'] = {
                        "_text": o.version
                    };
                }
                if (o.registry) {
                    obj['REGISTRY'] = {
                        "_text": o.registry
                    };
                }
                if (o.integrity) {
                    obj['INTEGRITY'] = {
                        "_text": o.integrity
                    };
                }
                if (Object.keys(obj).length > 0) {
                    dependencies.push(obj);
                }
            });
            if (dependencies.length > 0) {
                oAbapXml['asx:abap']['asx:values']['TRM_MANIFEST']['DEPENDENCIES'] = {
                    "item": dependencies
                };
            }
        }
        if (manifest.sapEntries) {
            var sapEntries = [];
            Object.keys(manifest.sapEntries).forEach(table => {
                try {
                    var tableItems = [];
                    manifest.sapEntries[table].forEach(r => {
                        var record = {};
                        Object.keys(r).forEach(k => {
                            record[k] = {
                                "_text": r[k]
                            };
                        });
                        if (Object.keys(record).length > 0) {
                            tableItems.push(record);
                        }
                    });
                    sapEntries.push({
                        "TABLE": table,
                        "ENTRIES": {
                            "item": tableItems
                        }
                    });
                }
                catch (e) { }
            });
            oAbapXml['asx:abap']['asx:values']['TRM_MANIFEST']['SAP_ENTRIES'] = {
                "item": sapEntries
            };
        }
        const sXml = xml.js2xml(oAbapXml, { compact: true });
        return sXml ? new xml_beautify_1.default({ useSelfClosingElement: true, parser: xmldom_1.DOMParser }).beautify(sXml) : null;
    }
    getPackage() {
        const manifest = this.get(true);
        const registry = new registry_1.Registry(manifest.registry || 'public');
        return new trmPackage_1.TrmPackage(manifest.name, registry, this);
    }
    static normalize(manifest, keepRuntimeValues) {
        if (!keepRuntimeValues) {
            delete manifest.linkedTransport;
            delete manifest.registry;
        }
        if (!manifest.name) {
            throw new Error('Package name missing.');
        }
        else {
            manifest.name = manifest.name.trim().toLowerCase().replace(/\s/g, '');
        }
        if (!manifest.version) {
            throw new Error('Package version missing.');
        }
        else {
            manifest.version = semver.clean(manifest.version);
            if (!manifest.version) {
                throw new Error('Invalid package version declared.');
            }
        }
        manifest.private = manifest.private ? true : false;
        manifest.backwardsCompatible = manifest.backwardsCompatible ? true : false;
        if (manifest.git) {
            try {
                manifest.git = (0, normalize_url_1.default)(manifest.git);
            }
            catch (e) {
                delete manifest.git;
            }
        }
        else {
            delete manifest.git;
        }
        if (manifest.website) {
            try {
                manifest.website = (0, normalize_url_1.default)(manifest.website);
            }
            catch (e) {
                delete manifest.website;
            }
        }
        else {
            delete manifest.website;
        }
        if (manifest.license) {
            try {
                const spdxLicenseIdsWrapper = SpdxLicenseIds;
                const aSpdxLicenseIds = spdxLicenseIdsWrapper.default;
                const inLicense = manifest.license.trim();
                const lLicense = inLicense.toLowerCase();
                const uLicense = inLicense.toUpperCase();
                if (aSpdxLicenseIds.includes(inLicense)) {
                    manifest.license = inLicense;
                }
                else if (aSpdxLicenseIds.includes(lLicense)) {
                    manifest.license = lLicense;
                }
                else if (aSpdxLicenseIds.includes(uLicense)) {
                    manifest.license = uLicense;
                }
                else {
                    delete manifest.license;
                }
            }
            catch (e) {
                delete manifest.license;
            }
        }
        else {
            delete manifest.license;
        }
        if (manifest.authors) {
            var aAuthors;
            if (typeof (manifest.authors) === 'string') {
                aAuthors = manifest.authors.split(',');
            }
            else {
                aAuthors = manifest.authors;
            }
            for (var i = 0; i < aAuthors.length; i++) {
                try {
                    var author;
                    if (typeof (aAuthors[i]) === 'string') {
                        author = getManifestAuthor(aAuthors[i]);
                    }
                    if (author.email) {
                        if (!(0, email_validator_1.validate)(author.email)) {
                            delete author.email;
                        }
                    }
                    aAuthors[i] = author;
                }
                catch (e) { }
            }
            manifest.authors = aAuthors;
            if (manifest.authors.length === 0) {
                delete manifest.authors;
            }
        }
        else {
            delete manifest.authors;
        }
        if (manifest.keywords) {
            var originalKeywords;
            if (typeof (manifest.keywords) === 'string') {
                originalKeywords = manifest.keywords.split(',');
            }
            else {
                originalKeywords = manifest.keywords;
            }
            manifest.keywords = [];
            for (var originalKeyword of originalKeywords) {
                try {
                    originalKeyword = originalKeyword.replace(/\s/g, '').toLowerCase();
                    manifest.keywords.push(originalKeyword);
                }
                catch (e) { }
            }
            if (manifest.keywords.length === 0) {
                delete manifest.keywords;
            }
        }
        else {
            delete manifest.keywords;
        }
        if (manifest.dependencies) {
            const originalDependencies = manifest.dependencies;
            manifest.dependencies = [];
            for (var originalDependency of originalDependencies) {
                try {
                    var dependency = {};
                    if (originalDependency.name) {
                        dependency.name = originalDependency.name.trim().toLowerCase().replace(/\s/g, '');
                        if (semver.validRange(originalDependency.version)) {
                            dependency.version = originalDependency.version;
                            dependency.integrity = originalDependency.integrity;
                            if (originalDependency.registry) {
                                dependency.registry = originalDependency.registry;
                            }
                            manifest.dependencies.push(dependency);
                        }
                    }
                }
                catch (e) { }
            }
            if (manifest.dependencies.length === 0) {
                delete manifest.dependencies;
            }
        }
        else {
            delete manifest.dependencies;
        }
        if (!manifest.sapEntries) {
            delete manifest.sapEntries;
        }
        if (manifest.distFolder) {
            try {
                manifest.distFolder = manifest.distFolder.replace(/^\//, '');
                manifest.distFolder = manifest.distFolder.replace(/\/$/, '');
            }
            catch (e) {
                delete manifest.distFolder;
            }
        }
        else {
            delete manifest.distFolder;
        }
        return manifest;
    }
    static fromAbapXml(sXml) {
        var _a, _b;
        var manifest;
        const oAbapXml = xml.xml2js(sXml, { compact: true });
        var oAbapManifest;
        try {
            oAbapManifest = (0, commons_1.normalize)(oAbapXml['asx:abap']['asx:values']['TRM_MANIFEST']);
            manifest = {
                name: oAbapManifest.name.text,
                version: oAbapManifest.version.text,
                backwardsCompatible: false,
                private: false,
                registry: 'public'
            };
        }
        catch (e) {
            throw new Error('XML Manifest is corrupted.');
        }
        if (oAbapManifest.description && oAbapManifest.description.text) {
            manifest.description = oAbapManifest.description.text;
        }
        if (oAbapManifest.backwardsCompatible && oAbapManifest.backwardsCompatible.text) {
            manifest.backwardsCompatible = oAbapManifest.backwardsCompatible.text === 'X';
        }
        if (oAbapManifest.private && oAbapManifest.private.text) {
            manifest.private = oAbapManifest.private.text === 'X';
        }
        if (oAbapManifest.registry && oAbapManifest.registry.text) {
            manifest.registry = oAbapManifest.registry;
        }
        if (oAbapManifest.git && oAbapManifest.git.text) {
            manifest.git = oAbapManifest.git.text;
        }
        if (oAbapManifest.website && oAbapManifest.website.text) {
            manifest.website = oAbapManifest.website.text;
        }
        if (oAbapManifest.license && oAbapManifest.license.text) {
            manifest.license = oAbapManifest.license.text;
        }
        if (oAbapManifest.keywords && oAbapManifest.keywords.item) {
            if (Array.isArray(oAbapManifest.keywords.item)) {
                manifest.keywords = oAbapManifest.keywords.item.map(o => o.text);
            }
            else {
                manifest.keywords = [oAbapManifest.keywords.item.text];
            }
        }
        if (oAbapManifest.authors && oAbapManifest.authors.item) {
            if (Array.isArray(oAbapManifest.authors.item)) {
                manifest.authors = oAbapManifest.authors.item.map(o => {
                    var _a, _b;
                    return {
                        name: (_a = o.name) === null || _a === void 0 ? void 0 : _a.text,
                        email: (_b = o.email) === null || _b === void 0 ? void 0 : _b.text
                    };
                });
            }
            else {
                manifest.authors = [{
                        name: (_a = oAbapManifest.authors.item.name) === null || _a === void 0 ? void 0 : _a.text,
                        email: (_b = oAbapManifest.authors.item.email) === null || _b === void 0 ? void 0 : _b.text
                    }];
            }
        }
        return new Manifest(Manifest.normalize(manifest, false));
    }
    static fromJson(sJson) {
        return new Manifest(Manifest.normalize(JSON.parse(sJson), false));
    }
    static compare(o1, o2, checkVersion = false) {
        const s1 = o1.getKey(checkVersion);
        const s2 = o2.getKey(checkVersion);
        return s1 === s2;
    }
}
exports.Manifest = Manifest;
