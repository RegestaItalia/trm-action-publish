"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = exports.COMMENT_OBJ = void 0;
const logger_1 = require("../logger");
const commons_1 = require("../commons");
const node_r3trans_1 = require("node-r3trans");
const TrmTransportIdentifier_1 = require("./TrmTransportIdentifier");
const manifest_1 = require("../manifest");
const promises_1 = require("timers/promises");
const fs = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const cliProgress = __importStar(require("cli-progress"));
exports.COMMENT_OBJ = 'ZTRM';
class Transport {
    constructor(trkorr, _systemConnector, _trTarget, _logger) {
        this.trkorr = trkorr;
        this._systemConnector = _systemConnector;
        this._trTarget = _trTarget;
        this._logger = _logger;
        this._logger = this._logger || logger_1.Logger.getDummy();
        this._fileNames = Transport._getFileNames(trkorr, this._systemConnector.getDest());
    }
    setTrmIdentifier(identifier) {
        this.trmIdentifier = identifier;
        return this;
    }
    getE070() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._e070) {
                const e070 = yield this._systemConnector.rfcClient.readTable('E070', [{ fieldName: 'TRKORR' }, { fieldName: 'AS4DATE' }, { fieldName: 'AS4TIME' }], `TRKORR EQ '${this.trkorr}'`);
                if (e070.length === 1) {
                    this._e070 = e070[0];
                }
            }
            return this._e070;
        });
    }
    getE071() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._e071) {
                this._e071 = yield this._systemConnector.rfcClient.readTable('E071', [{ fieldName: 'PGMID' }, { fieldName: 'OBJECT' }, { fieldName: 'OBJ_NAME' }], `TRKORR EQ '${this.trkorr}'`);
            }
            return this._e071;
        });
    }
    getDevclass() {
        return __awaiter(this, void 0, void 0, function* () {
            const aE071 = yield this.getE071();
            var aDevclass = aE071.filter(o => o.pgmid === 'R3TR' && o.object === 'DEVC').map(o => o.objName);
            for (const oE071 of aE071) {
                if (oE071.pgmid === 'R3TR') {
                    const tadir = yield this._systemConnector.getObject(oE071.pgmid, oE071.object, oE071.objName);
                    if (!aDevclass.includes(tadir.devclass)) {
                        aDevclass.push(tadir.devclass);
                    }
                }
            }
            var aTdevc = [];
            for (var devclass of aDevclass) {
                while (devclass) {
                    var tdevc = aTdevc.find(o => o.devclass === devclass);
                    if (!tdevc) {
                        tdevc = yield this._systemConnector.getDevclass(devclass);
                        aTdevc.push(tdevc);
                    }
                    devclass = tdevc.parentcl;
                }
            }
            var rootDevclass = null;
            while (aTdevc.length > 0 && !rootDevclass) {
                const hierarchy = (0, commons_1.getPackageHierarchy)(aTdevc);
                if (aDevclass.includes(hierarchy.devclass)) {
                    rootDevclass = hierarchy.devclass;
                }
                else {
                    aTdevc = aTdevc.filter(o => o.devclass !== hierarchy.devclass);
                }
            }
            return rootDevclass;
        });
    }
    getDate() {
        return __awaiter(this, void 0, void 0, function* () {
            const e070 = yield this.getE070();
            return (0, commons_1.fromAbapToDate)(e070.as4Date, e070.as4Time);
        });
    }
    isTrmRelevant() {
        return __awaiter(this, void 0, void 0, function* () {
            const e071 = yield this.getE071();
            const trmComments = e071.filter(o => o.pgmid === '*' && o.object === exports.COMMENT_OBJ);
            const hasName = trmComments.find(o => /name=/i.test(o.objName));
            const hasVersion = trmComments.find(o => /version=/i.test(o.objName));
            return (hasName && hasVersion) ? true : false;
        });
    }
    download(skipLog = false) {
        return __awaiter(this, void 0, void 0, function* () {
            var binaryTransport = {
                header: null,
                data: null
            };
            const logger = skipLog ? logger_1.Logger.getDummy() : this._logger;
            const filePaths = yield Transport._getFilePaths(this._fileNames, this._systemConnector, logger);
            logger.loading(`Reading ${this.trkorr} binary files...`);
            binaryTransport.header = yield this._systemConnector.rfcClient.getBinaryFile(filePaths.header);
            binaryTransport.data = yield this._systemConnector.rfcClient.getBinaryFile(filePaths.data);
            logger.success(`${this.trkorr} file read success.`);
            return {
                binaries: binaryTransport,
                filenames: this._fileNames
            };
        });
    }
    setDocumentation(sDocumentation, skipLog = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = skipLog ? logger_1.Logger.getDummy() : this._logger;
            this._docs = undefined;
            var doc = [];
            const indentationSplit = sDocumentation.split('\n');
            indentationSplit.forEach(s => {
                if (s.length <= 67) {
                    doc.push({
                        tdformat: '/',
                        tdline: s
                    });
                }
                else {
                    const sizeLimit = s.match(/.{1,67}/g) || [];
                    sizeLimit.forEach(sl => {
                        doc.push({
                            tdformat: '/',
                            tdline: sl
                        });
                    });
                }
            });
            logger.loading(`Setting ${this.trkorr} documentation...`);
            yield this._systemConnector.rfcClient.setTransportDoc(this.trkorr, doc);
            logger.success(`${this.trkorr} documentation updated.`);
            return this;
        });
    }
    getDocumentation(skipLog = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = skipLog ? logger_1.Logger.getDummy() : this._logger;
            if (!this._docs || this._docs.length === 0) {
                logger.loading(`Reading ${this.trkorr} documentation...`);
                const doktl = yield this._systemConnector.rfcClient.readTable('DOKTL', [{ fieldName: 'LANGU' }, { fieldName: 'DOKVERSION' }, { fieldName: 'LINE' }, { fieldName: 'DOKTEXT' }], `ID EQ 'TA' AND OBJECT EQ '${this.trkorr}'`);
                this._docs = Transport.doktlToDoc(doktl);
                this._docs = this._docs.sort((a, b) => b.version - a.version);
                logger.success(`Found ${this.trkorr} ${this._docs.length} documentation.`);
            }
            return this._docs;
        });
    }
    static doktlToDoc(doktl) {
        var aDocs = [];
        var trkorrDoktl = [];
        doktl.forEach(o => {
            const version = parseInt(o.dokversion);
            const lineNumber = parseInt(o.line);
            var arrayIndex = trkorrDoktl.findIndex(td => td.langu === o.langu && td.version === version);
            if (arrayIndex < 0) {
                arrayIndex = trkorrDoktl.push({
                    langu: o.langu,
                    version,
                    docLines: []
                });
                arrayIndex--;
            }
            trkorrDoktl[arrayIndex].docLines.push({
                no: lineNumber,
                value: o.doktext
            });
            trkorrDoktl[arrayIndex].docLines.sort((a, b) => a.no - b.no);
        });
        trkorrDoktl = trkorrDoktl.sort((a, b) => a.version - b.version);
        trkorrDoktl.forEach(o => {
            aDocs.push({
                langu: o.langu,
                version: o.version,
                value: o.docLines.map(o => o.value).join('')
            });
        });
        return aDocs;
    }
    addObjects(objects, lock) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._systemConnector.rfcClient.addToTransportRequest(this.trkorr, objects, lock);
        });
    }
    addComment(comment) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._systemConnector.rfcClient.addToTransportRequest(this.trkorr, [{
                    pgmid: '*',
                    object: exports.COMMENT_OBJ,
                    objName: comment
                }], false);
        });
    }
    addTranslations(aDevclass) {
        return __awaiter(this, void 0, void 0, function* () {
            var aDevclassLangFilter = [];
            aDevclass.forEach(d => {
                if (!aDevclassLangFilter.find(o => o.low === d)) {
                    aDevclassLangFilter.push({
                        sign: 'I',
                        option: 'EQ',
                        low: d
                    });
                }
            });
            yield this._systemConnector.rfcClient.addTranslationToTr(this.trkorr, aDevclassLangFilter);
        });
    }
    getLinkedPackage() {
        return __awaiter(this, void 0, void 0, function* () {
            const trmRelevant = yield this.isTrmRelevant();
            if (!trmRelevant) {
                return;
            }
            var oTrmPackage;
            const aDocumentation = yield this.getDocumentation();
            const logonLanguage = this._systemConnector.getLogonLanguage(true);
            const oDocumentationLang = aDocumentation.find(o => o.langu === logonLanguage);
            var docVal;
            if (oDocumentationLang) {
                docVal = oDocumentationLang.value;
            }
            else {
                if (aDocumentation.length > 0) {
                    docVal = aDocumentation[0].value;
                }
            }
            try {
                oTrmPackage = manifest_1.Manifest.fromAbapXml(docVal).setLinkedTransport(this).getPackage();
            }
            catch (e) {
            }
            return oTrmPackage;
        });
    }
    delete() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._systemConnector.rfcClient.deleteTrkorr(this.trkorr);
            return null;
        });
    }
    release(lock, skipLog = false, tmpFolder, secondsTimeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = skipLog ? logger_1.Logger.getDummy() : new logger_1.Logger(commons_1.CoreEnv.CLI, logger_1.TraceLevel.TRACE_ALL);
            logger.loading('Releasing...');
            yield this._systemConnector.rfcClient.releaseTrkorr(this.trkorr, lock, secondsTimeout);
            yield this._systemConnector.rfcClient.dequeueTransport(this.trkorr);
            if (!skipLog && tmpFolder) {
                logger.forceStop();
                yield this.readReleaseLog(tmpFolder, secondsTimeout);
                logger.loading(`Finalizing release...`);
            }
            yield this._isInTmsQueue(skipLog, false, secondsTimeout);
            return this;
        });
    }
    readReleaseLog(tmpFolder, secondsTimeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = new logger_1.Logger(commons_1.CoreEnv.CLI, logger_1.TraceLevel.TRACE_ALL);
            const filePaths = yield Transport._getFilePaths(this._fileNames, this._systemConnector, this._logger);
            const localPath = path_1.default.join(tmpFolder, this._fileNames.releaseLog);
            const oParser = new node_r3trans_1.R3transLogParser(localPath);
            const multibar = new cliProgress.MultiBar({
                clearOnComplete: true,
                hideCursor: true,
                format: '> {stage} [{bar}] {exitCode} {result} '
            }, cliProgress.Presets.legacy);
            var iEtp182 = 0;
            var iEtp183 = 0;
            var iEtp150 = 0;
            const etp182 = multibar.create(100, iEtp182, {
                stage: '',
                exitCode: '',
                result: 'Needs update'
            });
            const etp183 = multibar.create(100, iEtp183, {
                stage: '',
                exitCode: '',
                result: 'Needs update'
            });
            const etp150 = multibar.create(100, iEtp150, {
                stage: '',
                exitCode: '',
                result: 'Needs update'
            });
            const timeoutDate = new Date((new Date()).getTime() + (secondsTimeout * 1000));
            var exitWhile = false;
            var whileResult = null;
            while (!exitWhile && (new Date()).getTime() < timeoutDate.getTime()) {
                var logResult = [];
                try {
                    const logBinary = yield this._systemConnector.rfcClient.getBinaryFile(filePaths.releaseLog);
                    fs.writeFileSync(localPath, logBinary);
                    logResult = yield oParser.getReleaseLog();
                    fs.unlinkSync(localPath);
                }
                catch (e) {
                    logResult = [];
                }
                var etp182LogResult = logResult.find(o => o.id === 'ETP182') || { name: 'CHECK WRITEABILITY OF BUFFERS', exitCode: null };
                var etp183LogResult = logResult.find(o => o.id === 'ETP183') || { name: 'EXPORT PREPARATION', exitCode: null };
                var etp150LogResult = logResult.find(o => o.id === 'ETP150') || { name: 'MAIN EXPORT', exitCode: null };
                etp183LogResult.name += '           ';
                etp150LogResult.name += '                  ';
                const etp182ExitCode = node_r3trans_1.R3transLogParser.parseExitCode(etp182LogResult.exitCode);
                const etp183ExitCode = node_r3trans_1.R3transLogParser.parseExitCode(etp183LogResult.exitCode);
                const etp150ExitCode = node_r3trans_1.R3transLogParser.parseExitCode(etp150LogResult.exitCode);
                exitWhile = (etp182LogResult.exitCode !== null) && (etp183LogResult.exitCode !== null) && (etp150LogResult.exitCode !== null);
                if (etp182ExitCode.type === 'SUCCESS' || etp183ExitCode.type === 'SUCCESS' || etp150ExitCode.type === 'SUCCESS') {
                    whileResult = 'SUCCESS';
                }
                if (etp182ExitCode.type === 'WARNING' || etp183ExitCode.type === 'WARNING' || etp150ExitCode.type === 'WARNING') {
                    whileResult = 'WARNING';
                }
                if (etp182ExitCode.type === 'ERROR' || etp183ExitCode.type === 'ERROR' || etp150ExitCode.type === 'ERROR') {
                    whileResult = 'ERROR';
                }
                const etp182Payload = {
                    stage: etp182LogResult.name,
                    exitCode: etp182LogResult.exitCode || '',
                    result: etp182ExitCode.type !== 'UNKNOWN' ? etp182ExitCode.value : 'In progress'
                };
                const etp183Payload = {
                    stage: etp183LogResult.name,
                    exitCode: etp183LogResult.exitCode || '',
                    result: etp183ExitCode.type !== 'UNKNOWN' ? etp183ExitCode.value : 'In progress'
                };
                const etp150Payload = {
                    stage: etp150LogResult.name,
                    exitCode: etp150LogResult.exitCode || '',
                    result: etp150ExitCode.type !== 'UNKNOWN' ? etp150ExitCode.value : 'In progress'
                };
                if (iEtp182 < 99) {
                    if (etp182ExitCode.type === 'UNKNOWN') {
                        iEtp182++;
                    }
                    else {
                        iEtp182 = 100;
                    }
                }
                else {
                    if (etp182ExitCode.type === 'UNKNOWN') {
                        iEtp182++;
                    }
                }
                etp182.update(iEtp182, etp182Payload);
                if (iEtp183 < 99) {
                    if (etp183ExitCode.type === 'UNKNOWN') {
                        iEtp183++;
                    }
                    else {
                        iEtp183 = 100;
                    }
                }
                else {
                    if (etp183ExitCode.type === 'UNKNOWN') {
                        iEtp183++;
                    }
                }
                etp183.update(iEtp183, etp183Payload);
                if (iEtp150 < 99) {
                    if (etp150ExitCode.type === 'UNKNOWN') {
                        iEtp150++;
                    }
                    else {
                        iEtp150 = 100;
                    }
                }
                else {
                    if (etp150ExitCode.type === 'UNKNOWN') {
                        iEtp150++;
                    }
                }
                etp150.update(iEtp150, etp150Payload);
                yield (0, promises_1.setTimeout)(1000);
            }
            multibar.stop();
            var error;
            if (!exitWhile) {
                error = new Error(`Timed out waiting for release.`);
            }
            else {
                if (whileResult === "ERROR") {
                    error = new Error(`Error occurred during transport ${this.trkorr} release.`);
                }
                if (whileResult === "SUCCESS") {
                    logger.success(`Transport ${this.trkorr} released with success.`);
                }
                if (whileResult === "WARNING") {
                    logger.warning(`Transport ${this.trkorr} released with warning.`);
                }
            }
            if (error) {
                error['trkorrRollback'] = true;
                throw error;
            }
        });
    }
    readImportLog(tmpFolder) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    _isInTmsQueue(skipLog = false, checkImpSing = false, secondsTimeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = skipLog ? logger_1.Logger.getDummy() : this._logger;
            const timeoutDate = new Date((new Date()).getTime() + (secondsTimeout * 1000));
            var inQueue = false;
            if (this._trTarget) {
                var inQueueAttempts = 0;
                while (!inQueue && (new Date()).getTime() < timeoutDate.getTime()) {
                    inQueueAttempts++;
                    logger.loading(`Reading transport queue, attempt ${inQueueAttempts}...`);
                    var tmsQueue = yield this._systemConnector.rfcClient.readTmsQueue(this._trTarget);
                    tmsQueue = tmsQueue.filter(o => o.trkorr === this.trkorr);
                    tmsQueue = tmsQueue.sort((a, b) => parseInt(b.bufpos) - parseInt(a.bufpos));
                    if (!checkImpSing) {
                        inQueue = tmsQueue.length > 0;
                    }
                    else {
                        if (tmsQueue.length > 0) {
                            inQueue = tmsQueue[0].impsing !== 'X';
                        }
                        else {
                            inQueue = false;
                        }
                    }
                    yield (0, promises_1.setTimeout)(6000);
                }
                if (!inQueue) {
                    throw new Error(`Transport request not found in queue, timed out after ${inQueueAttempts + 1} attempts`);
                }
                else {
                    logger.success(`Transport was released.`);
                }
            }
            return inQueue;
        });
    }
    static _getFileNames(trkorr, targetSystem) {
        const trkorrRegex = /(\S{3})K(.*)/gi;
        const regexIterator = trkorr.matchAll(trkorrRegex);
        var trkorrFileExtension;
        var trkorrNumber;
        try {
            const matches = regexIterator.next().value;
            trkorrFileExtension = matches[1];
            trkorrNumber = matches[2];
        }
        catch (e) {
            throw new Error(`Couldn't parse transport ${trkorr}.`);
        }
        return {
            header: `K${trkorrNumber}.${trkorrFileExtension}`,
            data: `R${trkorrNumber}.${trkorrFileExtension}`,
            releaseLog: `${trkorrFileExtension}E${trkorrNumber}.${trkorrFileExtension}`,
            importLogH: `${trkorrFileExtension}H${trkorrNumber}.${targetSystem}`,
            importLogA: `${trkorrFileExtension}A${trkorrNumber}.${targetSystem}`,
            importLogI: `${trkorrFileExtension}I${trkorrNumber}.${targetSystem}`,
            importLogV: `${trkorrFileExtension}V${trkorrNumber}.${targetSystem}`,
            importLogR: `${trkorrFileExtension}R${trkorrNumber}.${targetSystem}`,
            importLogG: `${trkorrFileExtension}G${trkorrNumber}.${targetSystem}`
        };
    }
    static _getFilePaths(fileNames, systemConnector, logger = logger_1.Logger.getDummy()) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.loading(`Reading system data...`);
            const dirTrans = yield systemConnector.rfcClient.getDirTrans();
            const fileSys = yield systemConnector.rfcClient.getFileSystem();
            const pathSeparator = (0, commons_1.getFileSysSeparator)(fileSys.filesys);
            logger.success(`Data read success.`);
            return {
                header: `${dirTrans}${pathSeparator}cofiles${pathSeparator}${fileNames.header}`,
                data: `${dirTrans}${pathSeparator}data${pathSeparator}${fileNames.data}`,
                releaseLog: `${dirTrans}${pathSeparator}log${pathSeparator}${fileNames.releaseLog}`,
                importLogH: `${dirTrans}${pathSeparator}log${pathSeparator}${fileNames.importLogH}`,
                importLogA: `${dirTrans}${pathSeparator}log${pathSeparator}${fileNames.importLogA}`,
                importLogI: `${dirTrans}${pathSeparator}log${pathSeparator}${fileNames.importLogI}`,
                importLogV: `${dirTrans}${pathSeparator}log${pathSeparator}${fileNames.importLogV}`,
                importLogR: `${dirTrans}${pathSeparator}log${pathSeparator}${fileNames.importLogR}`,
                importLogG: `${dirTrans}${pathSeparator}log${pathSeparator}${fileNames.importLogG}`
            };
        });
    }
    static createToc(data, systemConnector, skipLog = false, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger = skipLog ? logger_1.Logger.getDummy() : logger;
            logger.loading(`Creating transport request (TOC)...`);
            const trkorr = yield systemConnector.rfcClient.createTocTransport(data.text, data.target);
            logger.success(`Transport request ${trkorr} generated successfully.`);
            return new Transport(trkorr, systemConnector, data.target, logger).setTrmIdentifier(data.trmIdentifier);
        });
    }
    static createLang(data, systemConnector, skipLog = false, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger = skipLog ? logger_1.Logger.getDummy() : logger;
            logger.loading(`Creating transport request (LANG)...`);
            const trkorr = yield systemConnector.rfcClient.createWbTransport(data.text, data.target);
            logger.success(`Transport request ${trkorr} generated successfully.`);
            return new Transport(trkorr, systemConnector, data.target, logger).setTrmIdentifier(TrmTransportIdentifier_1.TrmTransportIdentifier.LANG);
        });
    }
    static createWb(data, systemConnector, skipLog = false, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger = skipLog ? logger_1.Logger.getDummy() : logger;
            logger.loading(`Creating transport request (WB)...`);
            const trkorr = yield systemConnector.rfcClient.createWbTransport(data.text, data.target);
            logger.success(`Transport request ${trkorr} generated successfully.`);
            return new Transport(trkorr, systemConnector, null, logger);
        });
    }
    static getContent(data, tmpFolder) {
        return __awaiter(this, void 0, void 0, function* () {
            const r3trans = new node_r3trans_1.R3trans({
                tempDirPath: tmpFolder
            });
            const trkorr = yield r3trans.getTransportTrkorr(data);
            var transportContent = {
                trkorr,
                tdevc: [],
                tdevct: [],
                tadir: []
            };
            transportContent.tdevc = yield r3trans.getTableEntries(data, 'TDEVC');
            transportContent.tdevct = yield r3trans.getTableEntries(data, 'TDEVCT');
            transportContent.tadir = yield r3trans.getTableEntries(data, 'TADIR');
            return transportContent;
        });
    }
    static upload(data, skipLog = false, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const transportLogger = logger;
            logger = skipLog ? logger_1.Logger.getDummy() : logger;
            logger.loading(`Reading binary content...`);
            const fileContent = yield Transport.getContent(data.binary.data, data.tmpFolder);
            const trkorr = fileContent.trkorr;
            logger.success(`Transport ${trkorr} read success.`);
            const fileNames = Transport._getFileNames(trkorr, data.systemConnector.getDest());
            const filePaths = yield Transport._getFilePaths(fileNames, data.systemConnector, logger);
            logger.loading(`Uploading ${trkorr} header to "${filePaths.header}"...`);
            yield data.systemConnector.rfcClient.writeBinaryFile(filePaths.header, data.binary.header);
            logger.success(`Header uploaded successfully.`);
            logger.loading(`Uploading ${trkorr} data to "${filePaths.data}"...`);
            yield data.systemConnector.rfcClient.writeBinaryFile(filePaths.data, data.binary.data);
            logger.success(`Data uploaded successfully.`);
            logger.success(`Transport request ${trkorr} uploaded successfully.`);
            return new Transport(trkorr, data.systemConnector, data.trTarget, transportLogger);
        });
    }
    static getTransportsFromObject(objectKeys, systemConnector) {
        return __awaiter(this, void 0, void 0, function* () {
            var transports = [];
            const aSkipTrkorr = yield systemConnector.getIgnoredTrkorr();
            const objectInTransport = (yield systemConnector.rfcClient.readTable('E071', [{ fieldName: 'TRKORR' }], `PGMID EQ '${objectKeys.pgmid.trim().toUpperCase()}' AND OBJECT EQ '${objectKeys.object.trim().toUpperCase()}' AND OBJ_NAME EQ '${objectKeys.objName.trim().toUpperCase()}'`)).map(o => o.trkorr).filter(trkorr => !aSkipTrkorr.includes(trkorr));
            for (const trkorr of objectInTransport) {
                transports.push(new Transport(trkorr, systemConnector));
            }
            return transports;
        });
    }
    static getLatest(transports) {
        return __awaiter(this, void 0, void 0, function* () {
            var latest;
            for (const transport of transports) {
                if (!latest) {
                    latest = transport;
                }
                else {
                    if ((yield transport.getDate()) > (yield latest.getDate())) {
                        latest = transport;
                    }
                }
            }
            return latest;
        });
    }
    import(skipLog = false, timeout = 180) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._trTarget) {
                throw new Error('Missing transport target.');
            }
            yield this._systemConnector.rfcClient.forwardTransport(this.trkorr, this._trTarget, this._trTarget);
            yield this._systemConnector.rfcClient.importTransport(this.trkorr, this._trTarget);
            yield this._isInTmsQueue(skipLog, true, timeout);
        });
    }
    rename(as4text) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._systemConnector.rfcClient.renameTransportRequest(this.trkorr, as4text);
        });
    }
    canBeDeleted() {
        return __awaiter(this, void 0, void 0, function* () {
            const status = yield this._systemConnector.getTransportStatus(this.trkorr);
            return status === 'D';
        });
    }
    addObjectsFromTransport(from) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._systemConnector.rfcClient.trCopy(from, this.trkorr);
        });
    }
}
exports.Transport = Transport;
