"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SystemConnector = exports.SKIP_TRKORR_TABL = exports.SRC_TRKORR_TABL = exports.TRM_SERVER_PACKAGE_NAME = void 0;
const semver_1 = require("semver");
const logger_1 = require("../logger");
const manifest_1 = require("../manifest");
const registry_1 = require("../registry");
const client_1 = require("../rfc/client");
const transport_1 = require("../transport");
const trmPackage_1 = require("../trmPackage");
exports.TRM_SERVER_PACKAGE_NAME = 'trm-server';
exports.SRC_TRKORR_TABL = 'ZTRM_SRC_TRKORR';
exports.SKIP_TRKORR_TABL = 'ZTRM_SKIP_TRKORR';
class SystemConnector {
    constructor(_connection, _login, _logger) {
        this._connection = _connection;
        this._login = _login;
        this._logger = _logger;
        this._dest = this._connection.dest;
        this._lang = this._login.lang;
        this._user = this._login.user;
        this.address = this._connection.ashost;
        if (!this._connection.saprouter) {
            delete this._connection.saprouter;
        }
        this.rfcClient = new client_1.RFCClient(Object.assign(Object.assign({}, this._connection), this._login));
        this._logger = this._logger || logger_1.Logger.getDummy();
    }
    getDest() {
        return this._dest;
    }
    getLogonLanguage(c = false) {
        if (c) {
            return Array.from(this._lang)[0];
        }
        else {
            return this._lang;
        }
    }
    getLogonUser() {
        return this._user;
    }
    connect(skipLog = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = skipLog ? logger_1.Logger.getDummy() : this._logger;
            logger.loading(`Connecting to ${this._dest}...`);
            try {
                yield this.rfcClient.open();
                logger.success(`Connected to ${this._dest} as ${this._user}.`);
            }
            catch (e) {
                logger.error(`Connection to ${this._dest} as ${this._user} failed.`);
                throw e;
            }
        });
    }
    getPackageWorkbenchTransport(oPackage) {
        return __awaiter(this, void 0, void 0, function* () {
            var aTrkorr = (yield this.rfcClient.readTable('E071', [{ fieldName: 'TRKORR' }], `PGMID EQ '*' AND OBJECT EQ '${transport_1.COMMENT_OBJ}'`)).map(o => o.trkorr);
            aTrkorr = Array.from(new Set(aTrkorr));
            var aSkipTrkorr = [];
            for (const sTrkorr of aTrkorr) {
                const aTrkorrStatusCheck = (yield this.rfcClient.readTable('E070', [{ fieldName: 'TRKORR' }], `TRKORR EQ '${sTrkorr}' AND TRSTATUS EQ 'D'`));
                if (aTrkorrStatusCheck.length === 0) {
                    aSkipTrkorr.push(sTrkorr);
                }
            }
            aTrkorr = aTrkorr.filter(trkorr => !aSkipTrkorr.includes(trkorr));
            const transports = aTrkorr.map(trkorr => new transport_1.Transport(trkorr, this));
            var packageTransports = [];
            for (const transport of transports) {
                const transportPackage = yield transport.getLinkedPackage();
                if (transportPackage) {
                    if (trmPackage_1.TrmPackage.compare(transportPackage, oPackage)) {
                        packageTransports.push(transport);
                    }
                }
            }
            if (packageTransports.length > 0) {
                return yield transport_1.Transport.getLatest(packageTransports);
            }
            return null;
        });
    }
    getInstalledPackages(skipLog = false, includeSoruces = true) {
        return __awaiter(this, void 0, void 0, function* () {
            var trmPackages = [];
            var packageTransports = [];
            const aSourceTrkorr = includeSoruces ? (yield this.getSourceTrkorr()) : [];
            var aSkipTrkorr = yield this.getIgnoredTrkorr();
            var aTrkorr = (yield this.rfcClient.readTable('E071', [{ fieldName: 'TRKORR' }], `PGMID EQ '*' AND OBJECT EQ '${transport_1.COMMENT_OBJ}'`)).map(o => o.trkorr);
            aTrkorr = Array.from(new Set(aTrkorr));
            for (const sTrkorr of aTrkorr) {
                if (!aSourceTrkorr.includes(sTrkorr)) {
                    var aTrkorrStatusCheck;
                    try {
                        aTrkorrStatusCheck = (yield this.rfcClient.readTable('TMSBUFFER', [{ fieldName: 'TRKORR' }, { fieldName: 'MAXRC' }], `SYSNAM EQ '${this._dest}' AND TRKORR EQ '${sTrkorr}' AND IMPSING NE 'X'`)).filter(o => parseInt(o.maxrc) <= 4);
                    }
                    catch (e) {
                        aTrkorrStatusCheck = [];
                    }
                    if (aTrkorrStatusCheck.length === 0) {
                        aSkipTrkorr.push(sTrkorr);
                    }
                }
            }
            aTrkorr = aTrkorr.filter(trkorr => !aSkipTrkorr.includes(trkorr));
            const transports = aTrkorr.map(trkorr => new transport_1.Transport(trkorr, this));
            for (const transport of transports) {
                const trmPackage = yield transport.getLinkedPackage();
                if (trmPackage) {
                    var arrayIndex = packageTransports.findIndex(o => trmPackage_1.TrmPackage.compare(o.package, trmPackage));
                    if (arrayIndex < 0) {
                        arrayIndex = packageTransports.push({
                            package: trmPackage,
                            transports: []
                        });
                        arrayIndex--;
                    }
                    packageTransports[arrayIndex].transports.push(transport);
                }
            }
            for (const packageTransport of packageTransports) {
                const latestTransport = yield transport_1.Transport.getLatest(packageTransport.transports);
                if (latestTransport) {
                    trmPackages.push(yield latestTransport.getLinkedPackage());
                }
            }
            const oPublicRegistry = new registry_1.Registry('public');
            trmPackages = trmPackages.filter(o => !(o.packageName === exports.TRM_SERVER_PACKAGE_NAME && o.compareRegistry(oPublicRegistry)));
            const fugrExists = yield this.rfcClient.readTable('TADIR', [{ fieldName: 'OBJ_NAME' }], `PGMID EQ 'R3TR' AND OBJECT EQ 'FUGR' AND OBJ_NAME EQ 'ZTRM'`);
            if (fugrExists.length === 1) {
                try {
                    const trmServerVersion = yield this.rfcClient.getTrmServerVersion();
                    if ((0, semver_1.valid)(trmServerVersion)) {
                        trmPackages.push(new trmPackage_1.TrmPackage(exports.TRM_SERVER_PACKAGE_NAME, oPublicRegistry, new manifest_1.Manifest({
                            name: exports.TRM_SERVER_PACKAGE_NAME,
                            version: trmServerVersion
                        })));
                    }
                }
                catch (e) { }
            }
            return trmPackages;
        });
    }
    getDevclass(devclass) {
        return __awaiter(this, void 0, void 0, function* () {
            const tdevc = yield this.rfcClient.readTable('TDEVC', [{ fieldName: 'DEVCLASS' }, { fieldName: 'PARENTCL' }], `DEVCLASS EQ '${devclass.trim().toUpperCase()}'`);
            if (tdevc.length === 1) {
                return tdevc[0];
            }
        });
    }
    getTransportTargets() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.rfcClient.readTable('TMSCSYS', [{ fieldName: 'SYSNAM' }, { fieldName: 'SYSTXT' }]);
        });
    }
    getSubpackages(devclass) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryFields = [{ fieldName: 'DEVCLASS' }, { fieldName: 'PARENTCL' }];
            var subpackages = [];
            const initial = yield this.rfcClient.readTable('TDEVC', queryFields, `DEVCLASS EQ '${devclass.trim().toUpperCase()}'`);
            if (initial.length === 1) {
                subpackages.push({
                    tdevc: initial[0],
                    queryDone: false
                });
            }
            while (subpackages.find(o => !o.queryDone)) {
                const searchParentIndex = subpackages.findIndex(o => !o.queryDone);
                const tdevc = yield this.rfcClient.readTable('TDEVC', queryFields, `PARENTCL EQ '${subpackages[searchParentIndex].tdevc.devclass.trim().toUpperCase()}'`);
                subpackages[searchParentIndex].queryDone = true;
                tdevc.forEach(o => {
                    subpackages.push({
                        tdevc: o,
                        queryDone: false
                    });
                });
            }
            return subpackages.map(o => o.tdevc).filter(o => o.devclass !== devclass.trim().toUpperCase());
        });
    }
    getDevclassObjects(devclass, includeSubpackages = true) {
        return __awaiter(this, void 0, void 0, function* () {
            var aTadir = [];
            var aDevclass = [devclass];
            if (includeSubpackages) {
                aDevclass = aDevclass.concat(((yield this.getSubpackages(devclass)).map(o => o.devclass)));
            }
            for (const d of aDevclass) {
                aTadir = aTadir.concat(((yield this.rfcClient.getDevclassObjects(d.trim().toUpperCase()))));
            }
            return aTadir;
        });
    }
    getObject(pgmid, object, objName) {
        return __awaiter(this, void 0, void 0, function* () {
            const tadir = yield this.rfcClient.readTable('TADIR', [{ fieldName: 'PGMID' }, { fieldName: 'OBJECT' }, { fieldName: 'OBJ_NAME' }, { fieldName: 'DEVCLASS' }, { fieldName: 'SRCSYSTEM' }, { fieldName: 'AUTHOR' }], `PGMID EQ '${pgmid.trim().toUpperCase()}' AND OBJECT EQ '${object.trim().toUpperCase()}' AND OBJ_NAME EQ '${objName.trim().toUpperCase()}'`);
            if (tadir.length === 1) {
                return tadir[0];
            }
        });
    }
    getIgnoredTrkorr() {
        return __awaiter(this, void 0, void 0, function* () {
            const tablExists = yield this.rfcClient.readTable('TADIR', [{ fieldName: 'OBJ_NAME' }], `PGMID EQ 'R3TR' AND OBJECT EQ 'TABL' AND OBJ_NAME EQ '${exports.SKIP_TRKORR_TABL}'`);
            if (tablExists.length === 1) {
                const skipTrkorr = yield this.rfcClient.readTable(exports.SKIP_TRKORR_TABL, [{ fieldName: 'TRKORR' }]);
                return skipTrkorr.map(o => o.trkorr);
            }
            else {
                return [];
            }
        });
    }
    getSourceTrkorr() {
        return __awaiter(this, void 0, void 0, function* () {
            const tablExists = yield this.rfcClient.readTable('TADIR', [{ fieldName: 'OBJ_NAME' }], `PGMID EQ 'R3TR' AND OBJECT EQ 'TABL' AND OBJ_NAME EQ '${exports.SRC_TRKORR_TABL}'`);
            if (tablExists.length === 1) {
                const srcTrkorr = yield this.rfcClient.readTable(exports.SRC_TRKORR_TABL, [{ fieldName: 'TRKORR' }]);
                return srcTrkorr.map(o => o.trkorr);
            }
            else {
                return [];
            }
        });
    }
    addToIgnoredTrkorr(trkorr) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.rfcClient.addSkipTrkorr(trkorr);
        });
    }
    addToSrcTrkorr(trkorr) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.rfcClient.addSrcTrkorr(trkorr);
        });
    }
    getInstallPackages(packageName, registry) {
        return __awaiter(this, void 0, void 0, function* () {
            const registryEndpoint = registry.getRegistryType() === registry_1.RegistryType.PUBLIC ? 'public' : registry.endpoint;
            return yield this.rfcClient.readTable('ZTRMVINSTALLDEVC', [{ fieldName: 'ORIGINAL_DEVCLASS' }, { fieldName: 'INSTALL_DEVCLASS' }], `PACKAGE_NAME EQ '${packageName}' AND PACKAGE_REGISTRY EQ '${registryEndpoint}'`);
        });
    }
    setPackageSuperpackage(devclass, superpackage) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.rfcClient.tdevcInterface(devclass, superpackage);
        });
    }
    clearPackageSuperpackage(devclass) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.rfcClient.tdevcInterface(devclass, null, true);
        });
    }
    getMessage(data) {
        return __awaiter(this, void 0, void 0, function* () {
            var msgnr = data.no;
            while (msgnr.length < 3) {
                msgnr = `0${msgnr}`;
            }
            const aT100 = yield this.rfcClient.readTable('T100', [{ fieldName: 'SPRSL' }, { fieldName: 'ARBGB' }, { fieldName: 'MSGNR' }, { fieldName: 'TEXT' }], `SPRSL EQ '${this.getLogonLanguage(true)}' AND ARBGB EQ '${data.class}' AND MSGNR EQ '${msgnr}'`);
            if (aT100.length === 1) {
                var msg = aT100[0].text;
                msg = msg.replace(/&(1)?/, data.v1 || '');
                msg = msg.replace(/&(2)?/, data.v2 || '');
                msg = msg.replace(/&(3)?/, data.v3 || '');
                msg = msg.replace(/&(4)?/, data.v4 || '');
                return msg;
            }
            else {
                throw new Error(`Message ${msgnr}, class ${data.class}, lang ${this.getLogonLanguage(true)} not found.`);
            }
        });
    }
    checkSapEntryExists(table, sapEntry) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                var aQuery = [];
                Object.keys(sapEntry).forEach(k => {
                    aQuery.push(`${k.trim().toUpperCase()} EQ '${sapEntry[k]}'`);
                });
                const entry = yield this.rfcClient.readTable(table.trim().toUpperCase(), [{ fieldName: Object.keys(sapEntry)[0].trim().toUpperCase() }], aQuery.join(' AND '));
                return entry.length > 0;
            }
            catch (e) {
                return false;
            }
        });
    }
    ping() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.rfcClient.trmServerPing();
        });
    }
    getPackageIntegrity(oPackage) {
        return __awaiter(this, void 0, void 0, function* () {
            const packageName = oPackage.packageName;
            const registryEndpoint = oPackage.registry.getRegistryType() === registry_1.RegistryType.PUBLIC ? 'public' : oPackage.registry.endpoint;
            const aIntegrity = yield this.rfcClient.readTable('ZTRM_INTEGRITY', [{ fieldName: 'INTEGRITY' }], `PACKAGE_NAME EQ '${packageName}' AND PACKAGE_REGISTRY EQ '${registryEndpoint}'`);
            if (aIntegrity.length === 1) {
                return aIntegrity[0].integrity;
            }
            else {
                return '';
            }
        });
    }
}
exports.SystemConnector = SystemConnector;
