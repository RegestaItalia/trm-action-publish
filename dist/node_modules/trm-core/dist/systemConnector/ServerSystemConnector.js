"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerSystemConnector = exports.SKIP_TRKORR_TABL = exports.SRC_TRKORR_TABL = exports.TRM_SERVER_PACKAGE_NAME = void 0;
const semver_1 = require("semver");
const logger_1 = require("../logger");
const manifest_1 = require("../manifest");
const registry_1 = require("../registry");
const client_1 = require("../client");
const transport_1 = require("../transport");
const trmPackage_1 = require("../trmPackage");
const util_1 = require("util");
exports.TRM_SERVER_PACKAGE_NAME = 'trm-server';
exports.SRC_TRKORR_TABL = 'ZTRM_SRC_TRKORR';
exports.SKIP_TRKORR_TABL = 'ZTRM_SKIP_TRKORR';
class ServerSystemConnector {
    constructor(_connection, _login) {
        this._connection = _connection;
        this._login = _login;
        this._login.user = this._login.user.toUpperCase();
        this._lang = this._login.lang;
        this._user = this._login.user;
        if (!this._connection.saprouter) {
            delete this._connection.saprouter;
        }
        this._client = new client_1.RFCClient(Object.assign(Object.assign({}, this._connection), this._login));
    }
    getConnectionData() {
        return this._connection;
    }
    getDest() {
        return this._connection.dest;
    }
    getLogonLanguage(c = false) {
        if (c) {
            return Array.from(this._lang)[0];
        }
        else {
            return this._lang;
        }
    }
    getLogonUser() {
        return this._user;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.Logger.loading(`Connecting to ${this.getDest()}...`);
            try {
                yield this._client.open();
                logger_1.Logger.success(`Connected to ${this.getDest()} as ${this._user}.`, false);
            }
            catch (e) {
                logger_1.Logger.error(`Connection to ${this.getDest()} as ${this._user} failed.`, false);
                throw e;
            }
        });
    }
    checkConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.checkConnection();
        });
    }
    getTransportStatus(trkorr) {
        return __awaiter(this, void 0, void 0, function* () {
            const aTrkorrStatusCheck = (yield this.readTable('E070', [{ fieldName: 'TRKORR' }, { fieldName: 'TRSTATUS' }], `TRKORR EQ '${trkorr}'`));
            if (aTrkorrStatusCheck.length !== 1) {
                throw new Error(`Transport not found.`);
            }
            else {
                return aTrkorrStatusCheck[0].trstatus;
            }
        });
    }
    getPackageWorkbenchTransport(oPackage) {
        return __awaiter(this, void 0, void 0, function* () {
            var aTrkorr = (yield this.readTable('E071', [{ fieldName: 'TRKORR' }], `PGMID EQ '*' AND OBJECT EQ '${transport_1.COMMENT_OBJ}'`)).map(o => o.trkorr);
            aTrkorr = Array.from(new Set(aTrkorr));
            var aSkipTrkorr = [];
            for (const sTrkorr of aTrkorr) {
                var canBeReleased = false;
                try {
                    canBeReleased = (yield this.getTransportStatus(sTrkorr)) === 'D';
                }
                catch (e) {
                    canBeReleased = false;
                }
                if (!canBeReleased) {
                    aSkipTrkorr.push(sTrkorr);
                }
            }
            aTrkorr = aTrkorr.filter(trkorr => !aSkipTrkorr.includes(trkorr));
            const transports = aTrkorr.map(trkorr => new transport_1.Transport(trkorr));
            var packageTransports = [];
            for (const transport of transports) {
                const transportPackage = yield transport.getLinkedPackage();
                if (transportPackage) {
                    if (trmPackage_1.TrmPackage.compare(transportPackage, oPackage)) {
                        packageTransports.push(transport);
                    }
                }
            }
            if (packageTransports.length > 0) {
                return yield transport_1.Transport.getLatest(packageTransports);
            }
            return null;
        });
    }
    getInstalledPackages() {
        return __awaiter(this, arguments, void 0, function* (includeSoruces = true) {
            var trmPackages = [];
            var packageTransports = [];
            logger_1.Logger.log(`Ready to read installed packages`, true);
            logger_1.Logger.log(`Include sources: ${includeSoruces}`, true);
            const aSourceTrkorr = includeSoruces ? (yield this.getSourceTrkorr()) : [];
            logger_1.Logger.log(`Source trkorr ${JSON.stringify(aSourceTrkorr)}`, true);
            var aSkipTrkorr = yield this.getIgnoredTrkorr();
            logger_1.Logger.log(`Ignored trkorr ${JSON.stringify(aSkipTrkorr)}`, true);
            var aTrkorr = (yield this.readTable('E071', [{ fieldName: 'TRKORR' }], `PGMID EQ '*' AND OBJECT EQ '${transport_1.COMMENT_OBJ}'`)).map(o => o.trkorr);
            aTrkorr = Array.from(new Set(aTrkorr));
            for (const sTrkorr of aTrkorr) {
                if (!aSourceTrkorr.includes(sTrkorr)) {
                    logger_1.Logger.log(`${sTrkorr} not from source`, true);
                    var aTrkorrStatusCheck;
                    try {
                        logger_1.Logger.log(`Checking ${sTrkorr} TMS import result`, true);
                        aTrkorrStatusCheck = (yield this.readTable('TMSBUFFER', [{ fieldName: 'TRKORR' }, { fieldName: 'MAXRC' }], `SYSNAM EQ '${this.getDest()}' AND TRKORR EQ '${sTrkorr}' AND IMPSING NE 'X'`)).filter(o => parseInt(o.maxrc) <= 4);
                    }
                    catch (e) {
                        aTrkorrStatusCheck = [];
                    }
                    if (aTrkorrStatusCheck.length === 0) {
                        logger_1.Logger.log(`Adding ${sTrkorr} to skipped filter`, true);
                        aSkipTrkorr.push(sTrkorr);
                    }
                }
            }
            aTrkorr = aTrkorr.filter(trkorr => !aSkipTrkorr.includes(trkorr));
            logger_1.Logger.log(`Final transports ${JSON.stringify(aTrkorr)}`, true);
            const transports = aTrkorr.map(trkorr => new transport_1.Transport(trkorr));
            for (const transport of transports) {
                const trmPackage = yield transport.getLinkedPackage();
                if (trmPackage) {
                    logger_1.Logger.log(`Transport ${transport.trkorr}, found linked package`, true);
                    var arrayIndex = packageTransports.findIndex(o => trmPackage_1.TrmPackage.compare(o.package, trmPackage));
                    if (arrayIndex < 0) {
                        arrayIndex = packageTransports.push({
                            package: trmPackage,
                            transports: []
                        });
                        arrayIndex--;
                    }
                    packageTransports[arrayIndex].transports.push(transport);
                }
            }
            logger_1.Logger.log(`Package Transports map: ${(0, util_1.inspect)(packageTransports, { breakLength: Infinity, compact: true })}`, true);
            for (const packageTransport of packageTransports) {
                const latestTransport = yield transport_1.Transport.getLatest(packageTransport.transports);
                if (latestTransport) {
                    trmPackages.push(yield latestTransport.getLinkedPackage());
                }
            }
            logger_1.Logger.log(`Packages found: ${(0, util_1.inspect)(trmPackages, { breakLength: Infinity, compact: true })}`, true);
            logger_1.Logger.log(`Excluding trm-server (adding it manually)`, true);
            try {
                const trmServerPackage = trmPackages.find(o => o.packageName === exports.TRM_SERVER_PACKAGE_NAME && o.compareRegistry(new registry_1.Registry('public')));
                var generatedTrmServerPackage = yield this.generateTrmServerPackage();
                if (trmServerPackage && trmServerPackage.manifest) {
                    logger_1.Logger.log(`trm-server was found (it was imported via transport)`, true);
                    if (trmServerPackage.manifest.get().version === generatedTrmServerPackage.manifest.get().version) {
                        logger_1.Logger.log(`trm-server imported is the one currenlty in use`, true);
                        generatedTrmServerPackage.manifest = trmServerPackage.manifest;
                    }
                }
                trmPackages = trmPackages.filter(o => !(o.packageName === exports.TRM_SERVER_PACKAGE_NAME && o.compareRegistry(new registry_1.Registry('public'))));
                trmPackages.push(generatedTrmServerPackage);
            }
            catch (e) {
                logger_1.Logger.warning(`trm-server is not installed`, true);
            }
            return trmPackages;
        });
    }
    generateTrmServerPackage() {
        return __awaiter(this, void 0, void 0, function* () {
            var oPackage;
            const oPublicRegistry = new registry_1.Registry('public');
            const fugr = yield this.getObject('R3TR', 'FUGR', 'ZTRM');
            if (fugr) {
                try {
                    const trmServerVersion = yield this._client.getTrmServerVersion();
                    const oManifest = new manifest_1.Manifest({
                        name: exports.TRM_SERVER_PACKAGE_NAME,
                        version: trmServerVersion
                    });
                    if ((0, semver_1.valid)(trmServerVersion)) {
                        oPackage = new trmPackage_1.TrmPackage(exports.TRM_SERVER_PACKAGE_NAME, oPublicRegistry, oManifest).setDevclass(fugr.devclass);
                    }
                }
                catch (e) { }
            }
            if (!oPackage) {
                throw new Error(`Package ${exports.TRM_SERVER_PACKAGE_NAME} was not found.`);
            }
            return oPackage;
        });
    }
    getDevclass(devclass) {
        return __awaiter(this, void 0, void 0, function* () {
            const tdevc = yield this.readTable('TDEVC', [{ fieldName: 'DEVCLASS' }, { fieldName: 'PARENTCL' }], `DEVCLASS EQ '${devclass.trim().toUpperCase()}'`);
            if (tdevc.length === 1) {
                return tdevc[0];
            }
        });
    }
    getTransportTargets() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.readTable('TMSCSYS', [{ fieldName: 'SYSNAM' }, { fieldName: 'SYSTXT' }, { fieldName: 'SYSTYP' }]);
            }
            catch (e) {
                return yield this.readTable('TMSCSYS', [{ fieldName: 'SYSNAM' }, { fieldName: 'SYSTXT' }]);
            }
        });
    }
    getSubpackages(devclass) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryFields = [{ fieldName: 'DEVCLASS' }, { fieldName: 'PARENTCL' }];
            var subpackages = [];
            const initial = yield this.readTable('TDEVC', queryFields, `DEVCLASS EQ '${devclass.trim().toUpperCase()}'`);
            if (initial.length === 1) {
                subpackages.push({
                    tdevc: initial[0],
                    queryDone: false
                });
            }
            while (subpackages.find(o => !o.queryDone)) {
                const searchParentIndex = subpackages.findIndex(o => !o.queryDone);
                const tdevc = yield this.readTable('TDEVC', queryFields, `PARENTCL EQ '${subpackages[searchParentIndex].tdevc.devclass.trim().toUpperCase()}'`);
                subpackages[searchParentIndex].queryDone = true;
                tdevc.forEach(o => {
                    subpackages.push({
                        tdevc: o,
                        queryDone: false
                    });
                });
            }
            return subpackages.map(o => o.tdevc).filter(o => o.devclass !== devclass.trim().toUpperCase());
        });
    }
    getDevclassObjects(devclass_1) {
        return __awaiter(this, arguments, void 0, function* (devclass, includeSubpackages = true) {
            var aTadir = [];
            var aDevclass = [devclass];
            if (includeSubpackages) {
                aDevclass = aDevclass.concat(((yield this.getSubpackages(devclass)).map(o => o.devclass)));
            }
            for (const d of aDevclass) {
                aTadir = aTadir.concat(((yield this._client.getDevclassObjects(d.trim().toUpperCase()))));
            }
            return aTadir;
        });
    }
    getObject(pgmid, object, objName) {
        return __awaiter(this, void 0, void 0, function* () {
            const tadir = yield this.readTable('TADIR', [{ fieldName: 'PGMID' }, { fieldName: 'OBJECT' }, { fieldName: 'OBJ_NAME' }, { fieldName: 'DEVCLASS' }, { fieldName: 'SRCSYSTEM' }, { fieldName: 'AUTHOR' }], `PGMID EQ '${pgmid.trim().toUpperCase()}' AND OBJECT EQ '${object.trim().toUpperCase()}' AND OBJ_NAME EQ '${objName.trim().toUpperCase()}'`);
            if (tadir.length === 1) {
                return tadir[0];
            }
        });
    }
    getIgnoredTrkorr() {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.Logger.log(`Reading ignored transports`, true);
            logger_1.Logger.log(`Checking if ${exports.SKIP_TRKORR_TABL} exists`, true);
            const tablExists = yield this.readTable('TADIR', [{ fieldName: 'OBJ_NAME' }], `PGMID EQ 'R3TR' AND OBJECT EQ 'TABL' AND OBJ_NAME EQ '${exports.SKIP_TRKORR_TABL}'`);
            if (tablExists.length === 1) {
                logger_1.Logger.log(`TABLE ${exports.SKIP_TRKORR_TABL} exists`, true);
                const skipTrkorr = yield this.readTable(exports.SKIP_TRKORR_TABL, [{ fieldName: 'TRKORR' }]);
                return skipTrkorr.map(o => o.trkorr);
            }
            else {
                return [];
            }
        });
    }
    getSourceTrkorr() {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.Logger.log(`Ready to read installed packages`, true);
            logger_1.Logger.log(`Checking if ${exports.SRC_TRKORR_TABL} exists`, true);
            const tablExists = yield this.readTable('TADIR', [{ fieldName: 'OBJ_NAME' }], `PGMID EQ 'R3TR' AND OBJECT EQ 'TABL' AND OBJ_NAME EQ '${exports.SRC_TRKORR_TABL}'`);
            if (tablExists.length === 1) {
                logger_1.Logger.log(`TABL ${exports.SRC_TRKORR_TABL} exists`, true);
                const srcTrkorr = yield this.readTable(exports.SRC_TRKORR_TABL, [{ fieldName: 'TRKORR' }]);
                return srcTrkorr.map(o => o.trkorr);
            }
            else {
                return [];
            }
        });
    }
    getInstallPackages(packageName, registry) {
        return __awaiter(this, void 0, void 0, function* () {
            const registryEndpoint = registry.getRegistryType() === registry_1.RegistryType.PUBLIC ? 'public' : registry.endpoint;
            return yield this.readTable('ZTRMVINSTALLDEVC', [{ fieldName: 'ORIGINAL_DEVCLASS' }, { fieldName: 'INSTALL_DEVCLASS' }], `PACKAGE_NAME EQ '${packageName}' AND PACKAGE_REGISTRY EQ '${registryEndpoint}'`);
        });
    }
    setPackageSuperpackage(devclass, superpackage) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.tdevcInterface(devclass, superpackage);
        });
    }
    clearPackageSuperpackage(devclass) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.tdevcInterface(devclass, null, true);
        });
    }
    getMessage(data) {
        return __awaiter(this, void 0, void 0, function* () {
            var msgnr = data.no;
            while (msgnr.length < 3) {
                msgnr = `0${msgnr}`;
            }
            const aT100 = yield this.readTable('T100', [{ fieldName: 'SPRSL' }, { fieldName: 'ARBGB' }, { fieldName: 'MSGNR' }, { fieldName: 'TEXT' }], `SPRSL EQ '${this.getLogonLanguage(true)}' AND ARBGB EQ '${data.class}' AND MSGNR EQ '${msgnr}'`);
            if (aT100.length === 1) {
                var msg = aT100[0].text;
                msg = msg.replace(/&(1)?/, data.v1 || '');
                msg = msg.replace(/&(2)?/, data.v2 || '');
                msg = msg.replace(/&(3)?/, data.v3 || '');
                msg = msg.replace(/&(4)?/, data.v4 || '');
                return msg;
            }
            else {
                throw new Error(`Message ${msgnr}, class ${data.class}, lang ${this.getLogonLanguage(true)} not found.`);
            }
        });
    }
    checkSapEntryExists(table, sapEntry) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                var aQuery = [];
                Object.keys(sapEntry).forEach(k => {
                    aQuery.push(`${k.trim().toUpperCase()} EQ '${sapEntry[k]}'`);
                });
                const entry = yield this.readTable(table.trim().toUpperCase(), [{ fieldName: Object.keys(sapEntry)[0].trim().toUpperCase() }], aQuery.join(' AND '));
                return entry.length > 0;
            }
            catch (e) {
                return false;
            }
        });
    }
    ping() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._client.trmServerPing();
        });
    }
    getPackageIntegrity(oPackage) {
        return __awaiter(this, void 0, void 0, function* () {
            const packageName = oPackage.packageName;
            const registryEndpoint = oPackage.registry.getRegistryType() === registry_1.RegistryType.PUBLIC ? 'public' : oPackage.registry.endpoint;
            const aIntegrity = yield this.readTable('ZTRM_INTEGRITY', [{ fieldName: 'INTEGRITY' }], `PACKAGE_NAME EQ '${packageName}' AND PACKAGE_REGISTRY EQ '${registryEndpoint}'`);
            if (aIntegrity.length === 1) {
                return aIntegrity[0].integrity;
            }
            else {
                return '';
            }
        });
    }
    readTable(tableName, fields, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.readTable(tableName, fields, options);
        });
    }
    getFileSystem() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.getFileSystem();
        });
    }
    getDirTrans() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.getDirTrans();
        });
    }
    getBinaryFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.getBinaryFile(filePath);
        });
    }
    writeBinaryFile(filePath, binary) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.writeBinaryFile(filePath, binary);
        });
    }
    createTocTransport(text, target) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.createTocTransport(text, target);
        });
    }
    createWbTransport(text, target) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.createWbTransport(text, target);
        });
    }
    setTransportDoc(trkorr, doc) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.setTransportDoc(trkorr, doc);
        });
    }
    addToTransportRequest(trkorr, content, lock) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.addToTransportRequest(trkorr, content, lock);
        });
    }
    repositoryEnvironment(objectType, objectName) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.repositoryEnvironment(objectType, objectName);
        });
    }
    deleteTrkorr(trkorr) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.deleteTrkorr(trkorr);
        });
    }
    releaseTrkorr(trkorr, lock, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.releaseTrkorr(trkorr, lock, timeout);
        });
    }
    addSkipTrkorr(trkorr) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.addSkipTrkorr(trkorr);
        });
    }
    addSrcTrkorr(trkorr) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.addSrcTrkorr(trkorr);
        });
    }
    readTmsQueue(target) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.readTmsQueue(target);
        });
    }
    createPackage(scompkdtln) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.createPackage(scompkdtln);
        });
    }
    tdevcInterface(devclass, parentcl, rmParentCl) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.tdevcInterface(devclass, parentcl, rmParentCl);
        });
    }
    getDefaultTransportLayer() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.getDefaultTransportLayer();
        });
    }
    tadirInterface(tadir) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.tadirInterface(tadir);
        });
    }
    dequeueTransport(trkorr) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.dequeueTransport(trkorr);
        });
    }
    forwardTransport(trkorr, target, source, importAgain) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.forwardTransport(trkorr, target, source, importAgain);
        });
    }
    importTransport(trkorr, system) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.importTransport(trkorr, system);
        });
    }
    setInstallDevc(installDevc) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.setInstallDevc(installDevc);
        });
    }
    getObjectsList() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.getObjectsList();
        });
    }
    renameTransportRequest(trkorr, as4text) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.renameTransportRequest(trkorr, as4text);
        });
    }
    setPackageIntegrity(integrity) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.setPackageIntegrity(integrity);
        });
    }
    addTranslationToTr(trkorr, devclassFilter) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.addTranslationToTr(trkorr, devclassFilter);
        });
    }
    trCopy(from, to, doc) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._client.trCopy(from, to, doc);
        });
    }
    getFunctionModule(func) {
        return __awaiter(this, void 0, void 0, function* () {
            const aTfdir = yield this.readTable('TFDIR', [{ fieldName: 'FUNCNAME' }, { fieldName: 'PNAME' }], `FUNCNAME EQ '${func.trim().toUpperCase()}'`);
            if (aTfdir.length === 1) {
                return aTfdir[0];
            }
        });
    }
}
exports.ServerSystemConnector = ServerSystemConnector;
