"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = void 0;
const logger_1 = require("../../logger");
const trmPackage_1 = require("../../trmPackage");
const commons_1 = require("../../commons");
const crypto_1 = require("crypto");
exports.init = {
    name: 'init',
    run: (context) => __awaiter(void 0, void 0, void 0, function* () {
        var packageName = context.rawInput.packageName;
        var packageVersion = context.rawInput.version || 'latest';
        const registry = context.rawInput.registry;
        packageName = (0, commons_1.parsePackageName)({
            fullName: packageName
        }).fullName;
        if (packageVersion.trim().toLowerCase() === 'latest') {
            packageVersion = 'latest';
        }
        logger_1.Logger.loading(`Searching TRM package in registry ${registry.name}...`);
        const trmPackage = new trmPackage_1.TrmPackage(packageName, registry);
        const oArtifact = yield trmPackage.fetchRemoteArtifact(packageVersion);
        const installIntegrity = (0, crypto_1.createHash)("sha512").update(oArtifact.binary).digest("hex");
        const oManifest = yield trmPackage.fetchRemoteManifest(packageVersion);
        const trmManifest = oManifest.get();
        var sVersion = trmManifest.version;
        if (packageVersion === 'latest') {
            sVersion = `latest -> ${trmManifest.version}`;
        }
        logger_1.Logger.info(`"${trmManifest.name}" version ${sVersion} found in registry ${registry.name}`);
        context.runtime.registry = registry;
        context.runtime.manifest = oManifest;
        context.runtime.trmManifest = trmManifest;
        context.runtime.trmPackage = trmPackage;
        context.runtime.trmArtifact = oArtifact;
        context.runtime.workbenchObjects = [];
        context.runtime.trCopy = [];
        context.runtime.fetchedIntegrity = installIntegrity;
        context.parsedInput.systemPackages = context.rawInput.systemPackages || [];
        context.parsedInput.packageName = packageName;
        context.parsedInput.version = trmManifest.version;
        context.parsedInput.safeInstall = context.rawInput.safeInstall ? true : false;
        context.parsedInput.noInquirer = context.rawInput.silent ? true : false;
        context.parsedInput.forceDevclassInput = context.rawInput.silent ? false : true;
        if (context.rawInput.force) {
            context.parsedInput.skipAlreadyInstalledCheck = true;
            context.parsedInput.checkSapEntries = false;
            context.parsedInput.checkObjectTypes = false;
            context.parsedInput.forceInstallSameVersion = true;
            context.parsedInput.overwriteInstall = true;
            context.parsedInput.checkDependencies = false;
        }
        else {
            context.parsedInput.skipAlreadyInstalledCheck = false;
            context.parsedInput.checkSapEntries = context.rawInput.skipSapEntriesCheck ? false : true;
            context.parsedInput.checkObjectTypes = context.rawInput.skipObjectTypesCheck ? false : true;
            context.parsedInput.forceInstallSameVersion = false;
            context.parsedInput.overwriteInstall = context.rawInput.allowReplace ? true : false;
            context.parsedInput.checkDependencies = context.rawInput.ignoreDependencies ? false : true;
        }
        context.parsedInput.keepOriginalPackages = context.rawInput.keepOriginalDevclass ? true : false;
        context.parsedInput.installMissingDependencies = context.rawInput.ignoreDependencies ? false : true;
        context.parsedInput.transportLayer = context.rawInput.transportLayer;
        context.parsedInput.wbTrTargetSystem = context.rawInput.wbTrTargetSystem;
        context.parsedInput.installIntegrity = context.rawInput.integrity;
        context.parsedInput.r3transOptions = context.rawInput.r3transOptions;
        context.parsedInput.importTimeout = context.rawInput.importTimeout || 180;
        context.parsedInput.skipWbTransportGen = context.rawInput.generateTransport ? false : true;
        context.parsedInput.packageReplacements = context.rawInput.packageReplacements || [];
    })
};
