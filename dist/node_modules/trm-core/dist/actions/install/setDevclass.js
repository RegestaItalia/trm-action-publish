"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setDevclass = void 0;
const logger_1 = require("../../logger");
const systemConnector_1 = require("../../systemConnector");
const commons_1 = require("../../commons");
const Inquirer_1 = require("../../inquirer/Inquirer");
const registry_1 = require("../../registry");
function _validateDevclass(input, packagesNamespace) {
    const sInput = input.trim().toUpperCase();
    if (sInput.length > 30) {
        return `Package name must not exceede 30 characters limit.`;
    }
    if (packagesNamespace.startsWith('/')) {
        if (!sInput.startsWith(packagesNamespace)) {
            return `Package name must use namespace "${packagesNamespace}".`;
        }
        else {
            return true;
        }
    }
    else {
        return true;
    }
}
exports.setDevclass = {
    name: 'set-devclass',
    run: (context) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const tdevc = context.runtime.tdevcData;
        const keepOriginalPackages = context.parsedInput.keepOriginalPackages;
        const packageName = context.parsedInput.packageName;
        const registry = context.runtime.registry;
        const forceDevclassInput = context.parsedInput.forceDevclassInput;
        var packageReplacements = context.parsedInput.packageReplacements;
        const originalPackageHierarchy = (0, commons_1.getPackageHierarchy)(tdevc);
        if (keepOriginalPackages) {
            packageReplacements = tdevc.map(o => {
                return {
                    originalDevclass: o.devclass,
                    installDevclass: o.devclass
                };
            });
        }
        else {
            if (packageReplacements.length < 0) {
                packageReplacements = yield systemConnector_1.SystemConnector.getInstallPackages(packageName, registry);
            }
        }
        var rootDevclass = (_a = packageReplacements.find(o => o.originalDevclass === originalPackageHierarchy.devclass)) === null || _a === void 0 ? void 0 : _a.installDevclass;
        if (!rootDevclass) {
            rootDevclass = originalPackageHierarchy.devclass;
        }
        const packagesNamespace = (0, commons_1.getPackageNamespace)(rootDevclass);
        var inq1Prompts = [];
        tdevc.forEach(t => {
            const replacement = packageReplacements.find(o => o.originalDevclass === t.devclass);
            if (!replacement || forceDevclassInput) {
                if (context.parsedInput.noInquirer) {
                    logger_1.Logger.error(`There's no replacement devclass for "${t.devclass}" and running in silent context: exit!`, true);
                    throw new Error(`Can't continue install: running in silent and no action taken for devclass input`);
                }
                inq1Prompts.push({
                    type: "input",
                    name: t.devclass,
                    default: t.devclass,
                    message: `Input name for package "${t.devclass}"`,
                    validate: (input) => {
                        return _validateDevclass(input, packagesNamespace);
                    }
                });
            }
            else {
                const devclassValid = _validateDevclass(replacement.installDevclass, packagesNamespace);
                if (devclassValid !== true) {
                    throw new Error(devclassValid);
                }
            }
        });
        if (inq1Prompts.length > 0) {
            const inq1 = yield Inquirer_1.Inquirer.prompt(inq1Prompts);
            Object.keys(inq1).forEach(k => {
                packageReplacements = packageReplacements.filter(o => o.originalDevclass !== k);
                packageReplacements.push({
                    originalDevclass: k,
                    installDevclass: inq1[k].trim().toUpperCase()
                });
            });
        }
        logger_1.Logger.loading(`Updating install packages...`);
        var installDevc = [];
        packageReplacements.forEach(o => {
            installDevc.push({
                package_name: packageName,
                package_registry: registry.getRegistryType() === registry_1.RegistryType.PUBLIC ? registry_1.PUBLIC_RESERVED_KEYWORD : registry.endpoint,
                original_devclass: o.originalDevclass,
                install_devclass: o.installDevclass
            });
        });
        yield systemConnector_1.SystemConnector.setInstallDevc(installDevc);
        context.runtime.originalPackageHierarchy = originalPackageHierarchy;
        context.runtime.packageReplacements = packageReplacements;
    }),
    revert: (context) => __awaiter(void 0, void 0, void 0, function* () {
    })
};
