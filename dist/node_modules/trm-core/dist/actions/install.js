"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.install = void 0;
const registry_1 = require("../registry");
const semver = __importStar(require("semver"));
const trmPackage_1 = require("../trmPackage");
const manifest_1 = require("../manifest");
const installDependency_1 = require("./installDependency");
const transport_1 = require("../transport");
const commons_1 = require("../commons");
const node_r3trans_1 = require("node-r3trans");
const checkSapEntries_1 = require("./checkSapEntries");
const checkDependencies_1 = require("./checkDependencies");
const crypto_1 = require("crypto");
function _validateDevclass(input, packagesNamespace) {
    const sInput = input.trim().toUpperCase();
    if (sInput.length > 30) {
        return `Package name must not exceede 30 characters limit.`;
    }
    if (packagesNamespace.startsWith('/')) {
        if (!sInput.startsWith(packagesNamespace)) {
            return `Package name must use namespace ${packagesNamespace}.`;
        }
        else {
            return true;
        }
    }
    else {
        return true;
    }
}
function install(data, inquirer, system, registry, logger) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const ignoreSapEntries = data.ignoreSapEntries ? true : false;
        const skipDependencies = data.skipDependencies ? true : false;
        const ci = data.ci ? true : false;
        const importTimeout = data.importTimeout || 180;
        const forceInstall = data.forceInstall || ci ? true : false;
        const skipWbTransport = data.skipWbTransport ? true : false;
        const keepOriginalPackages = data.keepOriginalPackages ? true : false;
        const transportLayer = data.transportLayer;
        const targetSystem = data.targetSystem;
        const packageName = data.packageName.trim();
        const integrity = data.integrity;
        var version;
        if (!data.version || data.version.trim().toLowerCase() === 'latest') {
            version = 'latest';
        }
        else {
            version = semver.clean(data.version);
        }
        if (!version) {
            throw new Error(`Version not specified.`);
        }
        logger.loading(`Reading system data...`);
        const installedPackages = yield system.getInstalledPackages();
        const oTrmPackage = new trmPackage_1.TrmPackage(packageName, registry, null, logger);
        const oManifest = yield oTrmPackage.fetchRemoteManifest(version);
        var alreadyInstalled = installedPackages.find(o => manifest_1.Manifest.compare(o.manifest, oManifest, true)) ? true : false;
        if (integrity) {
            const installedIntegrity = yield system.getPackageIntegrity(oTrmPackage);
            alreadyInstalled = alreadyInstalled && installedIntegrity === integrity;
        }
        if (alreadyInstalled && !forceInstall) {
            logger.info(`Package "${packageName}" already installed, skipping installation. Run with --force.`);
            return;
        }
        const manifest = oManifest.get();
        if (!ignoreSapEntries) {
            logger.loading(`Checking system compatibility...`);
            const sapEntries = manifest.sapEntries || {};
            const oCheckSapEntries = yield (0, checkSapEntries_1.checkSapEntries)(sapEntries, system);
            const missingSapEntries = oCheckSapEntries.missingSapEntries;
            if (missingSapEntries.length > 0) {
                logger.error(`Missing SAP table entries.`);
                logger.error(`Please check the list below and, if necessary, check notes.`);
                missingSapEntries.forEach(o => {
                    var tableHead = [];
                    var tableData = [];
                    o.entries.forEach(entry => {
                        var tableRow = [];
                        Object.keys(entry).forEach(field => {
                            if (!tableHead.includes(field)) {
                                tableHead.push(field);
                            }
                            const columnIndex = tableHead.findIndex(f => f === field);
                            tableRow[columnIndex] = entry[field];
                        });
                        for (var i = 0; i < tableRow.length; i++) {
                            if (!tableRow[i]) {
                                tableRow[i] = '';
                            }
                        }
                        tableData.push(tableRow);
                    });
                    logger.error(` `);
                    logger.error(`Table ${o.table}:`);
                    logger.table(tableHead, tableData);
                });
                throw new Error(`There are a total of ${missingSapEntries.length} missing SAP table entries.`);
            }
        }
        logger.loading(`Checking dependencies...`);
        const dependencies = manifest.dependencies || [];
        const dependencyCheck = yield (0, checkDependencies_1.checkDependencies)({
            dependencies,
            installedPackages
        }, system);
        if (dependencyCheck.requiredDependenciesTab) {
            logger.info(`Package "${packageName}" has ${dependencyCheck.requiredDependenciesTab.data.length} dependencies.`);
            logger.table(dependencyCheck.requiredDependenciesTab.head, dependencyCheck.requiredDependenciesTab.data);
        }
        if (!skipDependencies) {
            for (const dependency of dependencyCheck.missingDependencies) {
                var oDependencyRegistry;
                if (registry.getRegistryType() === registry_1.RegistryType.PUBLIC && !dependency.registry) {
                    oDependencyRegistry = registry;
                }
                else {
                    oDependencyRegistry = new registry_1.Registry(dependency.registry || 'public');
                }
                var continueInstall = true;
                if (!ci) {
                    const inq1 = yield inquirer.prompt({
                        type: 'confirm',
                        name: 'continueInstall',
                        default: true,
                        message: `To continue, package ${dependency.name} version ${dependency.version} has to be installed. Continue?`
                    });
                    continueInstall = inq1.continueInstall;
                }
                if (continueInstall) {
                    logger.info(`Installing dependency ${dependency.name} version ${dependency.version}`);
                    yield (0, installDependency_1.installDependency)({
                        packageName: dependency.name,
                        versionRange: dependency.version,
                        integrity: dependency.integrity,
                        originalInstallOptions: data,
                        installedPackages
                    }, inquirer, system, oDependencyRegistry, logger);
                }
            }
        }
        logger.info(`Ready to install "${packageName}".`);
        if (alreadyInstalled) {
            const alreadyInstalledPackage = installedPackages.find(o => manifest_1.Manifest.compare(o.manifest, oManifest, false));
            const alreadyInstalledManifest = alreadyInstalledPackage.manifest.get();
            if (semver.gt(manifest.version, alreadyInstalledManifest.version)) {
                logger.info(`Upgrading "${packageName}", ${alreadyInstalledManifest.version} -> ${manifest.version}`);
            }
            else if (semver.lt(manifest.version, alreadyInstalledManifest.version)) {
                logger.warning(`Downgrading "${packageName}", ${alreadyInstalledManifest.version} -> ${manifest.version}`);
            }
        }
        logger.loading(`Getting transports...`);
        const oArtifact = yield oTrmPackage.fetchRemoteArtifact(manifest.version);
        const fetchedIntegrity = (0, crypto_1.createHash)("sha512").update(oArtifact.binary).digest("hex");
        if (integrity) {
            if (integrity !== fetchedIntegrity) {
                logger.warning(`ATTENTION!! Integrity check failed on package ${manifest.name}, version ${manifest.version}.`);
                logger.warning(`            Local:  ${integrity}`);
                logger.warning(`            Remote: ${fetchedIntegrity}`);
                logger.warning(`            This package MIGHT BE COMPROMISED.`);
                throw new Error(`Package installation aborted due to integrity check failure.`);
            }
        }
        const aTransports = yield oArtifact.getTransportBinaries();
        const r3trans = new node_r3trans_1.R3trans();
        const r3transVersion = yield r3trans.getVersion();
        logger.info(r3transVersion);
        logger.loading(`Reading transports...`);
        for (const transport of aTransports) {
            try {
                yield r3trans.isTransportValid(transport.binaries.data);
            }
            catch (e) {
                throw new Error(`Package contains invalid transport.`);
            }
        }
        const aDevcTransports = aTransports.filter(o => o.type === transport_1.TrmTransportIdentifier.DEVC);
        const aTadirTransports = aTransports.filter(o => o.type === transport_1.TrmTransportIdentifier.TADIR);
        var wbObjects = [];
        if (aDevcTransports.length > 1) {
            throw new Error(`Unexpected declaration of devclass in package ${packageName}.`);
        }
        else {
            var packageReplacements = [];
            logger.loading(`Checking transport content...`);
            var aTadir = [];
            for (const tadirTr of aTadirTransports) {
                aTadir = aTadir.concat((0, commons_1.normalize)(yield r3trans.getTableEntries(tadirTr.binaries.data, 'TADIR')));
            }
            wbObjects = wbObjects.concat(aTadir.map(o => {
                return {
                    pgmid: o.pgmid,
                    object: o.object,
                    objName: o.objName
                };
            }));
            const tdevc = (0, commons_1.normalize)(yield r3trans.getTableEntries(aDevcTransports[0].binaries.data, 'TDEVC'));
            const tdevct = (0, commons_1.normalize)(yield r3trans.getTableEntries(aDevcTransports[0].binaries.data, 'TDEVCT'));
            const systemObjectList = yield system.rfcClient.getObjectsList();
            aTadir.forEach(o => {
                if (!tdevc.find(k => k.devclass === o.devclass)) {
                    throw new Error(`Package includes objects without devclass.`);
                }
                if (!systemObjectList.find(k => k.pgmid === o.pgmid && k.object === o.object)) {
                    throw new Error(`Transport contains unknown object type ${o.pgmid} ${o.object}.`);
                }
            });
            const originalPackageHierarchy = (0, commons_1.getPackageHierarchy)(tdevc);
            if (keepOriginalPackages) {
                packageReplacements = tdevc.map(o => {
                    return {
                        originalDevclass: o.devclass,
                        installDevclass: o.devclass
                    };
                });
            }
            else {
                if (data.packageReplacements && data.packageReplacements.length > 0) {
                    packageReplacements = data.packageReplacements;
                }
                else {
                    packageReplacements = yield system.getInstallPackages(packageName, registry);
                }
            }
            var rootDevclass = (_a = packageReplacements.find(o => o.originalDevclass === originalPackageHierarchy.devclass)) === null || _a === void 0 ? void 0 : _a.installDevclass;
            if (!rootDevclass) {
                rootDevclass = originalPackageHierarchy.devclass;
            }
            logger.success(`Transport content ok.`);
            const packagesNamespace = (0, commons_1.getPackageNamespace)(rootDevclass);
            var inq1Prompts = [];
            tdevc.forEach(t => {
                const replacement = packageReplacements.find(o => o.originalDevclass === t.devclass);
                if (!replacement || forceInstall) {
                    inq1Prompts.push({
                        type: "input",
                        name: t.devclass,
                        default: t.devclass,
                        message: `Input name for package ${t.devclass}`,
                        validate: (input) => {
                            return _validateDevclass(input, packagesNamespace);
                        }
                    });
                }
                else {
                    const devclassValid = _validateDevclass(replacement.installDevclass, packagesNamespace);
                    if (devclassValid !== true) {
                        throw new Error(devclassValid);
                    }
                }
            });
            if (inq1Prompts.length > 0) {
                const inq1 = yield inquirer.prompt(inq1Prompts);
                Object.keys(inq1).forEach(k => {
                    packageReplacements = packageReplacements.filter(o => o.originalDevclass !== k);
                    packageReplacements.push({
                        originalDevclass: k,
                        installDevclass: inq1[k].trim().toUpperCase()
                    });
                });
            }
            logger.loading(`Updating install packages...`);
            var installDevc = [];
            packageReplacements.forEach(o => {
                installDevc.push({
                    package_name: packageName,
                    package_registry: registry.getRegistryType() === registry_1.RegistryType.PUBLIC ? 'public' : registry.endpoint,
                    original_devclass: o.originalDevclass,
                    install_devclass: o.installDevclass
                });
            });
            yield system.rfcClient.setInstallDevc(installDevc);
            logger.loading(`Generating devclass...`);
            var pdevclass = transportLayer;
            const dlvunit = (0, commons_1.getPackageNamespace)(packageReplacements[0].installDevclass) === '$' ? 'LOCAL' : 'HOME';
            for (const packageReplacement of packageReplacements) {
                const devclassExists = yield system.getDevclass(packageReplacement.installDevclass);
                const oDevcTadir = {
                    pgmid: 'R3TR',
                    object: 'DEVC',
                    objName: packageReplacement.installDevclass,
                    devclass: packageReplacement.installDevclass
                };
                if (!devclassExists) {
                    if (!pdevclass) {
                        pdevclass = yield system.rfcClient.getDefaultTransportLayer();
                    }
                    const ctext = ((_b = tdevct.find(o => o.devclass === packageReplacement.originalDevclass)) === null || _b === void 0 ? void 0 : _b.ctext) || `TRM ${packageName}`;
                    yield system.rfcClient.createPackage({
                        devclass: packageReplacement.installDevclass,
                        as4user: system.getLogonUser(),
                        ctext,
                        dlvunit,
                        pdevclass
                    });
                    if (dlvunit === 'HOME') {
                    }
                }
                yield system.rfcClient.tadirInterface(oDevcTadir);
                aTadir.push(oDevcTadir);
            }
            const aDummyTdevc = [];
            for (const packageReplacement of packageReplacements) {
                const originalRoot = originalPackageHierarchy.devclass === packageReplacement.originalDevclass;
                aDummyTdevc.push({
                    devclass: packageReplacement.installDevclass,
                    parentcl: originalRoot ? '' : tdevc.find(o => o.devclass === packageReplacement.originalDevclass).parentcl
                });
            }
            const installPackageHierarchy = (0, commons_1.getPackageHierarchy)(aDummyTdevc);
            for (const packageReplacement of packageReplacements) {
                const installRoot = installPackageHierarchy.devclass === packageReplacement.installDevclass;
                if (!installRoot) {
                    yield system.clearPackageSuperpackage(packageReplacement.installDevclass);
                }
            }
            for (const packageReplacement of packageReplacements) {
                const installRoot = installPackageHierarchy.devclass === packageReplacement.installDevclass;
                const originalParentCl = tdevc.find(o => o.devclass === packageReplacement.originalDevclass).parentcl;
                if (originalParentCl) {
                    const installParentCl = packageReplacements.find(o => o.originalDevclass === originalParentCl).installDevclass;
                    if (!installRoot) {
                        yield system.setPackageSuperpackage(packageReplacement.installDevclass, installParentCl);
                    }
                }
            }
            logger.success(`Devclass generated.`);
            logger.loading(`Importing transports...`);
            for (const tadirTr of aTadirTransports) {
                const oTransport = yield transport_1.Transport.upload({
                    binary: tadirTr.binaries,
                    systemConnector: system,
                    trTarget: system.getDest()
                }, true, logger);
                yield oTransport.import(false, importTimeout);
            }
            logger.success(`Transports imported.`);
            logger.loading(`Finishing TADIR import...`);
            for (var tadir of aTadir) {
                const replacementDevclass = packageReplacements.find(o => o.originalDevclass === tadir.devclass).installDevclass;
                tadir.devclass = replacementDevclass;
                tadir.srcsystem = 'TRM';
                yield system.rfcClient.tadirInterface(tadir);
            }
            logger.success(`TADIR import finished.`);
        }
        logger.loading(`Finalizing install...`);
        yield system.rfcClient.setPackageIntegrity({
            package_name: manifest.name,
            package_registry: registry.getRegistryType() === registry_1.RegistryType.PUBLIC ? 'public' : registry.endpoint,
            integrity: fetchedIntegrity
        });
        var wbObjectsAdd = [];
        for (const wbObject of wbObjects) {
            if (wbObject.pgmid === 'R3TR') {
                const objTadir = yield system.getObject(wbObject.pgmid, wbObject.object, wbObject.objName);
                const objPackageNs = (0, commons_1.getPackageNamespace)(objTadir.devclass);
                if (objPackageNs !== '$') {
                    wbObjectsAdd.push(objTadir);
                    if (!wbObjectsAdd.find(o => o.pgmid === 'R3TR' && o.object === 'DEVC' && o.objName === objTadir.devclass)) {
                        wbObjectsAdd.push({
                            pgmid: 'R3TR',
                            object: 'DEVC',
                            objName: objTadir.devclass
                        });
                    }
                }
            }
            else {
                wbObjectsAdd.push(wbObject);
            }
        }
        if (wbObjectsAdd.length > 0 && !skipWbTransport) {
            var wbTransport = yield system.getPackageWorkbenchTransport(oTrmPackage);
            if (!wbTransport) {
                wbTransport = yield transport_1.Transport.createWb({
                    text: `TRM generated transport`,
                    target: targetSystem
                }, system, true, logger);
            }
            yield wbTransport.addComment(`name=${manifest.name}`);
            yield wbTransport.addComment(`version=${manifest.version}`);
            yield wbTransport.setDocumentation(oManifest.getAbapXml());
            yield wbTransport.rename(`@X1@TRM: ${manifest.name} v${manifest.version}`);
            for (const wbObjectAdd of wbObjectsAdd) {
                try {
                    try {
                        yield wbTransport.addObjects([wbObjectAdd], true);
                    }
                    catch (e) {
                        yield wbTransport.addObjects([wbObjectAdd], false);
                    }
                }
                catch (e) {
                }
            }
            logger.success(`Use ${wbTransport.trkorr} for transports.`);
        }
        logger.success(`Install of package "${packageName}" finished.`);
    });
}
exports.install = install;
