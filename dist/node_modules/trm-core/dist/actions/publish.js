"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.publish = void 0;
const semver = __importStar(require("semver"));
const validators_1 = require("../inquirer/validators");
const manifest_1 = require("../manifest");
const registry_1 = require("../registry");
const transport_1 = require("../transport");
const trmPackage_1 = require("../trmPackage");
const TrmArtifact_1 = require("../trmPackage/TrmArtifact");
const findTadirDependencies_1 = require("./findTadirDependencies");
const commons_1 = require("../commons");
const crypto_1 = require("crypto");
function getTrmPackage(data, inquirer, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        var manifest = data.manifest;
        const ci = data.ci || false;
        const registry = data.registry;
        const overwriteManifestValues = data.overwriteManifestValues;
        const forceManifestInput = data.forceManifestInput;
        const usingLatest = manifest.version.trim().toLowerCase() === 'latest';
        if (!usingLatest) {
            manifest.version = semver.clean(manifest.version);
            if (!manifest.version) {
                throw new Error('Version not supported.');
            }
        }
        const trmPackage = new trmPackage_1.TrmPackage(manifest.name, registry);
        const alreadyPublished = yield trmPackage.exists();
        var latestPublishedVersion;
        if (alreadyPublished) {
            if (!(yield trmPackage.canPublishReleases())) {
                throw new Error(`You are not not authorized to publish "${trmPackage.packageName}" releases.`);
            }
            logger.warning(`A package named "${trmPackage.packageName}" is already pubished in registry "${trmPackage.registry.name}".`);
            const latestPublishedManifest = (yield trmPackage.fetchRemoteManifest('latest')).get();
            latestPublishedVersion = semver.clean(latestPublishedManifest.version);
            if (!usingLatest) {
                const versionAllowed = !(yield trmPackage.exists(manifest.version));
                if (!versionAllowed) {
                    throw new Error(`Package "${trmPackage.packageName}" versioned ${manifest.version} already published.`);
                }
            }
            else {
                manifest.version = semver.inc(latestPublishedManifest.version, 'patch');
                logger.info(`Latest version used, generated as ${manifest.version}`);
            }
            if (!overwriteManifestValues) {
                manifest.description = latestPublishedManifest.description;
                manifest.website = latestPublishedManifest.website;
                manifest.git = latestPublishedManifest.git;
                manifest.authors = latestPublishedManifest.authors;
                manifest.keywords = latestPublishedManifest.keywords;
                manifest.license = latestPublishedManifest.license;
            }
        }
        else {
            logger.info(`First time publishing "${trmPackage.packageName}". Congratulations!`);
            if (usingLatest) {
                manifest.version = trmPackage_1.DEFAULT_VERSION;
                logger.info(`Latest version used, generated as ${manifest.version}`);
            }
        }
        manifest = manifest_1.Manifest.normalize(manifest, false);
        if (alreadyPublished) {
            if (ci && typeof (manifest.backwardsCompatible) !== 'boolean') {
                throw new Error('Missing parameter "backwardsCompatible"');
            }
            const inq1 = yield inquirer.prompt({
                type: "confirm",
                message: `Is this release backwards compatible with the current latest release ${latestPublishedVersion}?`,
                name: "backwardsCompatible",
                when: !ci,
                default: true
            });
            manifest.backwardsCompatible = manifest.backwardsCompatible || inq1.backwardsCompatible;
        }
        else {
            manifest.backwardsCompatible = true;
        }
        if (ci && typeof (manifest.private) !== 'boolean') {
            throw new Error('Missing parameter "private"');
        }
        const inq2 = yield inquirer.prompt([{
                type: "list",
                message: "Package type",
                name: "packageType",
                default: "public",
                choices: [{
                        name: "Public (Visible to all users)",
                        value: "public"
                    }, {
                        name: "Private (Visible to you and users in organization, if specified)",
                        value: "private"
                    }],
                when: !alreadyPublished && !ci
            }]);
        if (!alreadyPublished || forceManifestInput) {
            const inq3 = yield inquirer.prompt([{
                    type: "input",
                    message: "Package short description",
                    name: "description",
                    default: manifest.description,
                    when: !ci
                }, {
                    type: "input",
                    message: "Website",
                    name: "website",
                    default: manifest.website,
                    when: !ci
                }, {
                    type: "input",
                    message: "Package Git repository",
                    name: "git",
                    default: manifest.git,
                    when: !ci
                }, {
                    type: "input",
                    message: "Authors (separated by comma)",
                    name: "authors",
                    when: !ci
                }, {
                    type: "input",
                    message: "Keywords (separated by comma)",
                    name: "keywords",
                    when: !ci
                }, {
                    type: "input",
                    message: "License",
                    name: "license",
                    default: manifest.license,
                    when: !ci
                }]);
            manifest.description = manifest.description || inq3.description;
            manifest.website = manifest.website || inq3.website;
            manifest.git = manifest.git || inq3.git;
            manifest.authors = manifest.authors || inq3.authors;
            manifest.keywords = manifest.keywords || inq3.keywords;
            manifest.license = manifest.license || inq3.license;
        }
        if (inq2.packageType) {
            manifest.private = inq2.packageType === 'private';
            if (manifest.private) {
                const parsedName = (0, commons_1.parsePackageName)({
                    fullName: manifest.name
                });
                if (!parsedName.organization) {
                    logger.warning(`Publishing a private package without a scope, this may not be allowed by the registry.`);
                }
            }
        }
        const oManifest = new manifest_1.Manifest(manifest);
        return new trmPackage_1.TrmPackage(manifest.name, registry, oManifest);
    });
}
function publish(data, inquirer, system, registry, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        var manifest = data.package;
        var devclass = data.devclass;
        var trTarget = data.target;
        const ci = data.ci;
        const skipDependencies = data.skipDependencies;
        if (ci) {
            data.forceManifestInput = false;
            data.overwriteManifestValues = true;
            data.skipEditDependencies = true;
            data.skipEditSapEntries = true;
            data.skipReadme = true;
        }
        manifest.name = manifest.name.toLowerCase().trim();
        logger.loading(`Checking package...`);
        manifest.version = yield trmPackage_1.TrmPackage.normalizeVersion(manifest.name, manifest.version, registry);
        const oDummyTrmPackage = new trmPackage_1.TrmPackage(manifest.name, registry);
        var publishAllowed = true;
        try {
            publishAllowed = yield oDummyTrmPackage.canPublishReleases();
        }
        catch (e) {
        }
        if (!publishAllowed) {
            throw new Error(`You are not not authorized to publish "${manifest.name}" releases.`);
        }
        else {
            logger.success(`Package check successful.`);
        }
        if (!devclass) {
            const inq1 = yield inquirer.prompt({
                type: "input",
                message: "Package devclass",
                name: "devclass",
                validate: (input) => __awaiter(this, void 0, void 0, function* () {
                    return yield (0, validators_1.validateDevclass)(input, system);
                })
            });
            devclass = inq1.devclass;
        }
        devclass = devclass.trim().toUpperCase();
        const devclassValid = yield (0, validators_1.validateDevclass)(devclass, system);
        if (devclassValid && devclassValid !== true) {
            throw new Error(devclassValid);
        }
        const systemTmscsys = yield system.getTransportTargets();
        if (!trTarget) {
            const inq2 = yield inquirer.prompt({
                type: "list",
                message: "Transport request target",
                name: "trTarget",
                validate: (input) => __awaiter(this, void 0, void 0, function* () {
                    return yield (0, validators_1.validateTransportTarget)(input, systemTmscsys);
                }),
                choices: systemTmscsys.map(o => {
                    return {
                        name: `${o.sysnam} (${o.systxt})`,
                        value: o.sysnam
                    };
                })
            });
            trTarget = inq2.trTarget.trim().toUpperCase();
        }
        else {
            trTarget = trTarget.trim().toUpperCase();
            const trTargetValid = yield (0, validators_1.validateTransportTarget)(trTarget, systemTmscsys);
            if (trTargetValid && trTargetValid !== true) {
                throw new Error(trTargetValid);
            }
        }
        logger.loading(`Reading package objects...`);
        const allTadir = yield system.getDevclassObjects(devclass, true);
        if (!manifest.dependencies) {
            manifest.dependencies = [];
        }
        if (!manifest.sapEntries) {
            manifest.sapEntries = {};
        }
        var tadirDependencies = [];
        if (!skipDependencies) {
            logger.loading(`Searching dependencies...`);
            tadirDependencies = yield (0, findTadirDependencies_1.findTadirDependencies)({
                devclass,
                tadir: allTadir
            }, system, logger);
        }
        else {
            logger.info(`Skipping dependencies.`);
            logger.warning(`Skipping dependencies can cause your package to fail activation. Make sure to manually edit the dependencies if necessary.`);
        }
        var dependenciesError;
        tadirDependencies.forEach(d => {
            if (!d.trmPackage) {
                if (d.isSap) {
                    if (!manifest.sapEntries['TADIR']) {
                        manifest.sapEntries['TADIR'] = [];
                    }
                    d.tadir.forEach(t => {
                        var arrayIndex = manifest.sapEntries['TADIR'].findIndex(o => o['PGMID'] === t.pgmid && o['OBJECT'] === t.object && o['OBJ_NAME'] === t.objName);
                        if (arrayIndex < 0) {
                            arrayIndex = manifest.sapEntries['TADIR'].push({
                                "PGMID": t.pgmid,
                                "OBJECT": t.object,
                                "OBJ_NAME": t.objName
                            });
                            arrayIndex--;
                        }
                    });
                }
                else {
                    dependenciesError = `All objects must be included in a TRM Package in order to continue.`;
                    d.tadir.forEach(t => {
                        logger.error(`Object ${t.object} ${t.objName} of devclass ${t.devclass} has no TRM Package.`);
                    });
                }
            }
            else {
                const dependencyManifest = d.trmPackage.manifest.get();
                const dependencyName = dependencyManifest.name;
                const dependencyVersion = `^${dependencyManifest.version}`;
                const dependencyIntegrity = d.integrity;
                const dependencyRegistry = d.trmPackage.registry.getRegistryType() === registry_1.RegistryType.PUBLIC ? undefined : d.trmPackage.registry.endpoint;
                var arrayIndex = manifest.dependencies.findIndex(o => o.name === dependencyName);
                if (arrayIndex < 0) {
                    arrayIndex = manifest.dependencies.push({
                        name: dependencyName,
                        version: dependencyVersion,
                        integrity: dependencyIntegrity,
                        registry: dependencyRegistry
                    });
                    arrayIndex--;
                }
                manifest.dependencies[arrayIndex].version = dependencyVersion;
                manifest.dependencies[arrayIndex].integrity = dependencyIntegrity;
                if (registry_1.Registry.compare(d.trmPackage.registry, registry)) {
                    logger.info(`Found dependency with package "${dependencyName}", version "${dependencyVersion}"`);
                }
                else {
                    const dependencyRegistryName = d.trmPackage.registry.getRegistryType() === registry_1.RegistryType.PUBLIC ? 'public' : d.trmPackage.registry.endpoint;
                    logger.warning(`Found dependency with package "${dependencyName}", version "${dependencyVersion}", on a "${dependencyRegistryName}" registry!`);
                }
                if (!dependencyIntegrity) {
                    dependenciesError = `Dependency "${dependencyName}", package integrity not found.`;
                }
            }
        });
        if (dependenciesError) {
            throw new Error(dependenciesError);
        }
        else {
            const skipEditSapEntries = data.skipEditSapEntries || false;
            const skipEditDependencies = data.skipEditDependencies || false;
            if (manifest.sapEntries && manifest.sapEntries['TADIR']) {
                logger.info(`This package requires ${manifest.sapEntries['TADIR'].length} SAP objects.`);
            }
            if (manifest.dependencies.length > 0) {
                logger.info(`Found ${manifest.dependencies.length} dependencies.`);
            }
            else {
                logger.info(`No dependencies with TRM packages found.`);
            }
            const inq3 = yield inquirer.prompt([{
                    message: `Manually edit required SAP entries? (MIGHT NEED ENTER TWICE)`,
                    type: 'confirm',
                    name: 'editSapEntries',
                    default: false,
                    when: !skipEditSapEntries
                }, {
                    message: 'Edit SAP entries',
                    type: 'editor',
                    name: 'sapEntries',
                    postfix: '.json',
                    when: (hash) => {
                        return hash.editSapEntries;
                    },
                    default: manifest.sapEntries ? JSON.stringify(manifest.sapEntries, null, 2) : '{}',
                    validate: (input) => {
                        try {
                            JSON.parse(input);
                            return true;
                        }
                        catch (e) {
                            return 'Invalid JSON';
                        }
                    }
                }]);
            const inq4 = yield inquirer.prompt([{
                    message: `Manually edit dependencies? ${skipEditSapEntries ? '(MIGHT NEED ENTER TWICE)' : ''}`,
                    type: 'confirm',
                    name: 'editDependencies',
                    default: false,
                    when: !skipEditDependencies
                }, {
                    message: 'Editor dependencies',
                    type: 'editor',
                    name: 'dependencies',
                    postfix: '.json',
                    when: (hash) => {
                        return hash.editDependencies;
                    },
                    default: manifest.dependencies ? JSON.stringify(manifest.dependencies, null, 2) : '[]',
                    validate: (input) => {
                        try {
                            JSON.parse(input);
                            return true;
                        }
                        catch (e) {
                            return 'Invalid JSON';
                        }
                    }
                }]);
            if (inq3.sapEntries) {
                manifest.sapEntries = JSON.parse(inq3.sapEntries);
            }
            else {
                manifest.sapEntries = manifest.sapEntries || {};
            }
            if (inq4.dependencies) {
                manifest.dependencies = JSON.parse(inq4.dependencies);
            }
            else {
                manifest.dependencies = manifest.dependencies || [];
            }
        }
        const oTrmPackage = yield getTrmPackage({
            manifest,
            registry,
            overwriteManifestValues: data.overwriteManifestValues,
            forceManifestInput: data.forceManifestInput,
            ci
        }, inquirer, logger);
        const sManifestXml = oTrmPackage.manifest.getAbapXml();
        const skipReadme = data.skipReadme || false;
        var readme = data.readme;
        const inq4 = yield inquirer.prompt([{
                message: 'Write readme?',
                type: 'confirm',
                name: 'editReadme',
                default: false,
                when: !skipReadme
            }, {
                message: 'Write readme',
                type: 'editor',
                name: 'readme',
                postfix: '.md',
                when: (hash) => {
                    return hash.editReadme;
                },
                default: readme || ''
            }]);
        if (inq4.readme) {
            readme = inq4.readme;
        }
        else {
            readme = readme || '';
        }
        var rollBackTransports = false;
        const objectsOnly = allTadir.filter(o => !(o.pgmid === 'R3TR' && o.object === 'DEVC'));
        const devcOnly = allTadir.filter(o => o.pgmid === 'R3TR' && o.object === 'DEVC');
        logger.loading(`Generating transports...`);
        const devcToc = yield transport_1.Transport.createToc({
            trmIdentifier: transport_1.TrmTransportIdentifier.DEVC,
            target: trTarget,
            text: `@X1@TRM: ${manifest.name} v${manifest.version} (D)`
        }, system, true, logger);
        const tadirToc = yield transport_1.Transport.createToc({
            trmIdentifier: transport_1.TrmTransportIdentifier.TADIR,
            target: trTarget,
            text: `@X1@TRM: ${manifest.name} v${manifest.version}`
        }, system, true, logger);
        try {
            yield tadirToc.addComment(`name=${manifest.name}`);
            yield tadirToc.addComment(`version=${manifest.version}`);
            yield tadirToc.setDocumentation(sManifestXml);
            yield tadirToc.addObjects(objectsOnly, false);
            yield devcToc.addObjects(devcOnly, false);
        }
        catch (e) {
            rollBackTransports = true;
            throw e;
        }
        finally {
            if (rollBackTransports) {
                yield tadirToc.delete();
                yield devcToc.delete();
            }
        }
        const timeout = data.releaseTimeout || 180;
        const tmpFolder = data.tmpFolder;
        var devcTocReleased = false;
        try {
            logger.forceStop();
            yield tadirToc.release(false, false, tmpFolder, timeout);
            logger.loading(`Finalizing release...`);
            yield devcToc.release(false, true, tmpFolder, timeout);
            devcTocReleased = true;
            logger.loading(`Creating TRM Artifact...`);
            const trmArtifact = yield TrmArtifact_1.TrmArtifact.create([
                tadirToc,
                devcToc
            ], oTrmPackage.manifest, true);
            logger.loading(`Publishing...`);
            yield oTrmPackage.publish({
                artifact: trmArtifact,
                packageName: oTrmPackage.manifest.get().name,
                packageVersion: oTrmPackage.manifest.get().version,
                readme
            });
            yield system.addToSrcTrkorr(tadirToc.trkorr);
            if (process.env.TRM_ENV === 'DEV') {
                rollBackTransports = true;
            }
            else {
                const integrity = (0, crypto_1.createHash)("sha512").update(trmArtifact.binary).digest("hex");
                yield system.rfcClient.setPackageIntegrity({
                    package_name: oTrmPackage.manifest.get().name,
                    package_registry: oTrmPackage.registry.getRegistryType() === registry_1.RegistryType.PUBLIC ? 'public' : oTrmPackage.registry.endpoint,
                    integrity
                });
            }
            logger.success(`+ ${oTrmPackage.manifest.get().name} v${oTrmPackage.manifest.get().version}`);
        }
        catch (e) {
            rollBackTransports = true;
            throw e;
        }
        finally {
            if (rollBackTransports) {
                yield system.addToIgnoredTrkorr(tadirToc.trkorr);
                logger.error(`Transport ${tadirToc.trkorr} rollback.`);
                if (!devcTocReleased) {
                    yield devcToc.delete();
                    logger.error(`Transport ${devcToc.trkorr} rollback.`);
                }
            }
        }
    });
}
exports.publish = publish;
