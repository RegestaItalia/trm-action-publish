"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setTrmDependencies = void 0;
const logger_1 = require("../../logger");
const registry_1 = require("../../registry");
exports.setTrmDependencies = {
    name: 'set-trm-dependencies',
    filter: (context) => __awaiter(void 0, void 0, void 0, function* () {
        const trmDependencies = context.runtime.dependencies.trmDependencies;
        if (trmDependencies.length > 0) {
            return true;
        }
        else {
            logger_1.Logger.log(`Skipping TRM dependencies search beacuse no TRM packages were found`, true);
            return false;
        }
    }),
    run: (context) => __awaiter(void 0, void 0, void 0, function* () {
        const trmDependencies = context.runtime.dependencies.trmDependencies;
        trmDependencies.forEach(d => {
            const dependencyManifest = d.trmPackage.manifest.get();
            const dependencyName = dependencyManifest.name;
            const dependencyVersion = `^${dependencyManifest.version}`;
            const dependencyIntegrity = d.integrity;
            const dependencyRegistry = d.trmPackage.registry.getRegistryType() === registry_1.RegistryType.PUBLIC ? undefined : d.trmPackage.registry.endpoint;
            var arrayIndex = context.runtime.manifest.dependencies.findIndex(o => o.name === dependencyName);
            if (arrayIndex < 0) {
                arrayIndex = context.runtime.manifest.dependencies.push({
                    name: dependencyName,
                    version: dependencyVersion,
                    integrity: dependencyIntegrity,
                    registry: dependencyRegistry
                });
                arrayIndex--;
            }
            context.runtime.manifest.dependencies[arrayIndex].version = dependencyVersion;
            context.runtime.manifest.dependencies[arrayIndex].integrity = dependencyIntegrity;
            if (registry_1.Registry.compare(d.trmPackage.registry, context.runtime.registry)) {
                logger_1.Logger.info(`Found dependency with package "${dependencyName}", version "${dependencyVersion}"`);
            }
            else {
                const dependencyRegistryName = d.trmPackage.registry.getRegistryType() === registry_1.RegistryType.PUBLIC ? registry_1.PUBLIC_RESERVED_KEYWORD : d.trmPackage.registry.endpoint;
                logger_1.Logger.info(`Found dependency with package "${dependencyName}", version "${dependencyVersion}", registry "${dependencyRegistryName}"`);
            }
            if (!dependencyIntegrity) {
                throw new Error(`Dependency "${dependencyName}", package integrity not found.`);
            }
        });
    })
};
