"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = void 0;
const logger_1 = require("../../logger");
const trmPackage_1 = require("../../trmPackage");
const Inquirer_1 = require("../../inquirer/Inquirer");
const semver_1 = require("semver");
const commons_1 = require("../../commons");
exports.init = {
    name: 'init',
    run: (context) => __awaiter(void 0, void 0, void 0, function* () {
        const registry = context.rawInput.registry;
        if (process.env.TRM_ENV === 'DEV') {
            logger_1.Logger.warning(`Running in development, rolling back after publish (PACKAGE WON'T BE UNPUBLISHED FROM REGISTRY!)`);
        }
        var packageName = context.rawInput.package.name.toLowerCase().trim();
        packageName = (0, commons_1.parsePackageName)({
            fullName: packageName
        }).fullName;
        var packageVersion = context.rawInput.package.version;
        if (!packageVersion) {
            throw new Error(`Package version empty.`);
        }
        context.parsedInput.silent = context.rawInput.silent;
        var normalizeVersion = true;
        var normalizedVersion;
        logger_1.Logger.loading(`Checking package version...`);
        while (normalizeVersion) {
            normalizedVersion = yield trmPackage_1.TrmPackage.normalizeVersion(packageName, packageVersion, registry);
            if (normalizedVersion !== packageVersion) {
                logger_1.Logger.info(`Version ${packageVersion} -> ${normalizedVersion}`);
                const inq1 = yield Inquirer_1.Inquirer.prompt([{
                        name: 'acceptNormalized',
                        message: `Continue publish as version ${normalizedVersion}?`,
                        type: 'confirm',
                        default: true,
                        when: !context.parsedInput.silent
                    }, {
                        name: 'inputVersion',
                        message: `Input version to publish`,
                        type: 'input',
                        when: (hash) => {
                            return !context.parsedInput.silent && !hash.acceptNormalized;
                        },
                        validate: (input) => {
                            if (!input) {
                                return false;
                            }
                            else {
                                if (input.trim().toLowerCase() === 'latest') {
                                    return true;
                                }
                                else {
                                    return (0, semver_1.clean)(input) ? true : false;
                                }
                            }
                        }
                    }]);
                if (inq1.acceptNormalized || context.parsedInput.silent) {
                    normalizeVersion = false;
                }
                else {
                    normalizeVersion = true;
                    packageVersion = inq1.inputVersion;
                }
            }
            else {
                normalizeVersion = false;
            }
        }
        context.parsedInput.packageName = packageName;
        context.parsedInput.version = normalizedVersion;
        context.parsedInput.releaseFolder = context.rawInput.tmpFolder;
        context.parsedInput.releaseTimeout = context.rawInput.releaseTimeout || 180;
        context.parsedInput.customizingTransports = context.rawInput.customizingTransports || [];
        context.parsedInput.skipEditSapEntries = context.rawInput.skipEditSapEntries;
        context.parsedInput.skipEditDependencies = context.rawInput.skipEditDependencies;
        context.parsedInput.skipDependencies = context.rawInput.skipDependencies;
        context.parsedInput.skipLang = context.rawInput.skipLang;
        context.parsedInput.overwriteManifestValues = context.rawInput.overwriteManifestValues;
        context.parsedInput.packageBackwardsCompatible = context.rawInput.package ? context.rawInput.package.backwardsCompatible : null;
        context.parsedInput.skipCust = context.rawInput.skipCust;
        context.parsedInput.devclass = context.rawInput.devclass;
        context.parsedInput.forceManifestInput = context.rawInput.forceManifestInput;
        context.parsedInput.packagePrivate = context.rawInput.package ? context.rawInput.package.private : null;
        context.parsedInput.skipReadme = context.rawInput.skipReadme;
        context.parsedInput.readme = context.rawInput.readme || '';
        context.parsedInput.target = context.rawInput.target;
        context.runtime.registry = registry;
        context.runtime.dummyPackage = new trmPackage_1.TrmPackage(packageName, registry);
        context.runtime.manifest = context.rawInput.package;
        context.runtime.manifest.name = packageName;
        context.runtime.manifest.version = normalizedVersion;
        if (!context.runtime.manifest.sapEntries) {
            context.runtime.manifest.sapEntries = {};
        }
        if (!context.runtime.manifest.dependencies) {
            context.runtime.manifest.dependencies = [];
        }
    })
};
