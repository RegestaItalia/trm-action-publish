"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setTrmDependencies = void 0;
const systemConnector_1 = require("../../systemConnector");
const transport_1 = require("../../transport");
const trmPackage_1 = require("../../trmPackage");
const logger_1 = require("../../logger");
var aRootDevclass = [];
const _getRootDevclass = (devclass) => __awaiter(void 0, void 0, void 0, function* () {
    const oRootDevclass = aRootDevclass.find(o => o.devclass === devclass);
    if (oRootDevclass) {
        return oRootDevclass.rootDevclass;
    }
    else {
        logger_1.Logger.loading(`Searching root of devclass ${devclass}...`, true);
        var tdevcDevclass = devclass;
        var rootDevclass = null;
        while (rootDevclass === null) {
            const tdevc = yield systemConnector_1.SystemConnector.getDevclass(tdevcDevclass);
            logger_1.Logger.log(`Parent of ${tdevcDevclass} is ${tdevc.parentcl}`, true);
            if (tdevc.parentcl) {
                tdevcDevclass = tdevc.parentcl;
                aRootDevclass.push({
                    devclass: tdevcDevclass,
                    rootDevclass: tdevc.parentcl
                });
            }
            else {
                rootDevclass = tdevcDevclass;
                aRootDevclass.push({
                    devclass: tdevcDevclass,
                    rootDevclass: tdevcDevclass
                });
            }
        }
        logger_1.Logger.success(`Root devclass of ${devclass} is ${rootDevclass}`, true);
        return rootDevclass;
    }
});
const _getTadirDependencies = (tadirDependencies) => __awaiter(void 0, void 0, void 0, function* () {
    var trmDependencies = [];
    for (const tadirDependency of tadirDependencies) {
        const tadir = tadirDependency.tableDependency;
        var trmRelevantTransports = [];
        var latestTransport;
        var devclass;
        var trmPackage;
        var integrity;
        var arrayIndex1;
        var arrayIndex2;
        logger_1.Logger.log(`Searching transports for object ${tadir.PGMID} ${tadir.OBJECT} ${tadir.OBJ_NAME}`, true);
        const allTransports = yield transport_1.Transport.getTransportsFromObject({
            pgmid: tadir.PGMID,
            object: tadir.OBJECT,
            objName: tadir.OBJ_NAME
        });
        logger_1.Logger.log(`Found ${allTransports.length} transports for object ${tadir.PGMID} ${tadir.OBJECT} ${tadir.OBJ_NAME}`, true);
        for (const transport of allTransports) {
            if (yield transport.isTrmRelevant()) {
                logger_1.Logger.log(`Transport ${transport.trkorr} is TRM relevant`, true);
                trmRelevantTransports.push(transport);
            }
        }
        latestTransport = yield transport_1.Transport.getLatest(trmRelevantTransports);
        if (latestTransport) {
            logger_1.Logger.log(`Latest transport is ${latestTransport.trkorr}`, true);
            trmPackage = yield latestTransport.getLinkedPackage();
            const alreadyInArray = trmDependencies.find(o => o.trmPackage && trmPackage_1.TrmPackage.compare(o.trmPackage, trmPackage));
            if (alreadyInArray) {
                devclass = alreadyInArray.devclass;
                integrity = alreadyInArray.integrity;
            }
            else {
                integrity = yield systemConnector_1.SystemConnector.getPackageIntegrity(trmPackage);
                if (!integrity) {
                    throw new Error(`Package "${trmPackage.packageName}", integrity not found!`);
                }
                try {
                    devclass = yield latestTransport.getDevclass();
                }
                catch (e) {
                    devclass = '';
                }
            }
        }
        else {
            logger_1.Logger.log(`Object without TRM package`, true);
            devclass = yield _getRootDevclass(tadir.DEVCLASS);
        }
        arrayIndex1 = trmDependencies.findIndex(o => o.devclass === devclass);
        if (arrayIndex1 < 0) {
            arrayIndex1 = trmDependencies.push({
                devclass,
                trmPackage,
                integrity,
                sapEntries: []
            });
            arrayIndex1--;
        }
        arrayIndex2 = trmDependencies[arrayIndex1].sapEntries.findIndex(o => o.table === 'TADIR');
        if (arrayIndex2 < 0) {
            arrayIndex2 = trmDependencies[arrayIndex1].sapEntries.push({
                table: 'TADIR',
                dependencies: []
            });
            arrayIndex2--;
        }
        trmDependencies[arrayIndex1].sapEntries[arrayIndex2].dependencies.push(tadirDependency);
    }
    return trmDependencies;
});
exports.setTrmDependencies = {
    name: 'set-trm-dependencies',
    filter: (context) => __awaiter(void 0, void 0, void 0, function* () {
        const aParsedSenvi = context.runtime.parsedSenvi || [];
        if (aParsedSenvi.length === 0) {
            logger_1.Logger.log(`Skipping set TRM dependencies (no custom object found)`, true);
            return false;
        }
        else {
            return true;
        }
    }),
    run: (context) => __awaiter(void 0, void 0, void 0, function* () {
        const aParsedSenvi = context.runtime.parsedSenvi;
        var trmDependencies = [];
        logger_1.Logger.loading(`Searching TRM dependencies...`);
        for (const parsedSenvi of aParsedSenvi) {
            if (parsedSenvi.table === 'TADIR') {
                trmDependencies = trmDependencies.concat(yield _getTadirDependencies(parsedSenvi.dependencies));
            }
        }
        context.output.trmDependencies = trmDependencies.filter(o => o.trmPackage);
        context.output.unknownDependencies = trmDependencies.filter(o => !o.trmPackage);
    })
};
