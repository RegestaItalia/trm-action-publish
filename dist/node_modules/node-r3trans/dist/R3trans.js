"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.R3trans = void 0;
const fs = __importStar(require("fs"));
const R3transFile_1 = require("./R3transFile");
const child_process_1 = require("child_process");
const uuid_1 = require("uuid");
const path_1 = __importDefault(require("path"));
const R3transLogParser_1 = require("./R3transLogParser");
class R3trans {
    constructor(options) {
        if (options) {
            this.r3transDirPath = options.r3transDirPath || process.env.R3TRANS_HOME;
            this.tempDirPath = options.tempDirPath;
        }
        else {
            this.r3transDirPath = process.env.R3TRANS_HOME;
        }
        if (!this.r3transDirPath) {
            throw new Error(`R3TRANS_HOME path is not defined.`);
        }
        if (!this.tempDirPath) {
            try {
                fs.accessSync(this.r3transDirPath, fs.constants.W_OK);
                this.tempDirPath = this.r3transDirPath;
            }
            catch (err) {
                throw new Error(`R3TRANS_HOME path doesn't have write access.`);
            }
        }
        else {
            try {
                fs.accessSync(this.tempDirPath, fs.constants.W_OK);
            }
            catch (err) {
                throw new Error(`Temporary file path doesn't have write access.`);
            }
        }
    }
    _exec(args, log, verbose) {
        var logFilePath;
        const errorCodes = [8, 12, 16];
        if (log) {
            const logFileName = `${(0, uuid_1.v4)()}.log`;
            logFilePath = path_1.default.join(this.tempDirPath, logFileName);
            args = `${args} -w ${logFilePath}`;
            if (verbose) {
                args = `${args} -v ${verbose}`;
            }
        }
        return new Promise((res, rej) => {
            (0, child_process_1.exec)(`R3trans ${args || ''}`, {
                cwd: this.r3transDirPath
            }, (error, stdout, stderr) => {
                if (args) {
                    if (error && errorCodes.includes(error.code)) {
                        rej(error);
                    }
                }
                res({
                    code: error ? error.code : 0,
                    output: stdout,
                    logFile: logFilePath ? new R3transFile_1.R3transFile(logFilePath, true) : null
                });
            });
        });
    }
    _getTransportFile(data) {
        if (Buffer.isBuffer(data)) {
            return R3transFile_1.R3transFile.fromBuffer(this.tempDirPath, data);
        }
        else {
            return R3transFile_1.R3transFile.fromPath(data);
        }
    }
    getVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._version) {
                const oExec = yield this._exec();
                if (oExec.code === 12) {
                    try {
                        this._version = oExec.output.split(/\r?\n|\r|\n/g)[0];
                    }
                    catch (e) {
                        //
                    }
                }
            }
            return this._version;
        });
    }
    isTransportValid(data) {
        return __awaiter(this, void 0, void 0, function* () {
            var valid = false;
            const transport = this._getTransportFile(data);
            try {
                const oExec = yield this._exec(`-l ${transport.filePath}`, true);
                oExec.logFile.dispose();
                valid = true;
            }
            catch (e) {
                valid = false;
            }
            finally {
                transport.dispose();
            }
            return valid;
        });
    }
    getLogBuffer(data, verbose) {
        return __awaiter(this, void 0, void 0, function* () {
            var buffer;
            const transport = this._getTransportFile(data);
            try {
                const oExec = yield this._exec(`-l ${transport.filePath}`, true, verbose);
                buffer = oExec.logFile.getBuffer();
                oExec.logFile.dispose();
            }
            catch (e) {
                throw e;
            }
            finally {
                transport.dispose();
            }
            return buffer;
        });
    }
    getTableStructure(data, tableName) {
        return __awaiter(this, void 0, void 0, function* () {
            var tableStructure;
            const transport = this._getTransportFile(data);
            try {
                const oExec = yield this._exec(`-l ${transport.filePath}`, true, 4);
                const parser = new R3transLogParser_1.R3transLogParser(oExec.logFile.filePath);
                tableStructure = yield parser.getTableStructure(tableName);
                oExec.logFile.dispose();
            }
            catch (e) {
                throw e;
            }
            finally {
                transport.dispose();
            }
            return tableStructure;
        });
    }
    getTableEntries(data, tableName) {
        return __awaiter(this, void 0, void 0, function* () {
            var tableEntries;
            const transport = this._getTransportFile(data);
            try {
                const oExec = yield this._exec(`-l ${transport.filePath}`, true, 4);
                const parser = new R3transLogParser_1.R3transLogParser(oExec.logFile.filePath);
                tableEntries = yield parser.getTableEntries(tableName);
                oExec.logFile.dispose();
            }
            catch (e) {
                throw e;
            }
            finally {
                transport.dispose();
            }
            return tableEntries;
        });
    }
    getTransportTrkorr(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const e070 = yield this.getTableEntries(data, 'E070');
            if (e070.length === 1) {
                return e070[0].TRKORR;
            }
            else {
                throw new Error('Trkorr not found.');
            }
        });
    }
}
exports.R3trans = R3trans;
//# sourceMappingURL=R3trans.js.map